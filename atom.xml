<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[sigh]]></title>
  <subtitle><![CDATA[音乐是情感的独白]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wangximing.github.io/"/>
  <updated>2016-09-19T14:46:12.000Z</updated>
  <id>http://wangximing.github.io/</id>
  
  <author>
    <name><![CDATA[王西明]]></name>
    <email><![CDATA[sighwang@outlook.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://wangximing.github.io/2016/09/19/vue/"/>
    <id>http://wangximing.github.io/2016/09/19/vue/</id>
    <published>2016-09-19T14:46:12.000Z</published>
    <updated>2016-09-19T14:46:12.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>v-bind 绑定动态 Props 到父组件的数据。每当父组件的数据变化时，也会传导给子组件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="title">input</span> <span class="attribute">v-model</span>=<span class="value">"parentMsg"</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="title">br</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="title">child</span> <span class="attribute">v-bind:my-message</span>=<span class="value">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="title">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 v-bind 的缩写语法通常更简单：</p>
<pre><code>&lt;child <span class="symbol">:my-message=<span class="string">"parentMsg"</span>&gt;&lt;/child&gt;</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>v-bind 绑定动态 Props 到父组件的数据。每当父组件的数据变化时，也会传导给子组件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span cl]]>
    </summary>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangximing.github.io/2016/09/02/ES67/"/>
    <id>http://wangximing.github.io/2016/09/02/ES67/</id>
    <published>2016-09-02T02:44:42.000Z</published>
    <updated>2016-09-02T02:44:42.000Z</updated>
    <content type="html"><![CDATA[<h3 id="let_const">let const</h3><h4 id="let">let</h4><ul>
<li>声明临时变量，在块级作用域</li>
<li>不存在变量提升</li>
<li><p>暂时性死区</p>
<blockquote>
<p>变量必须在声明后使用，不然会报错。称之为暂时性死区</p>
</blockquote>
</li>
<li>不允许重复声明</li>
</ul>
<h4 id="块级作用域">块级作用域</h4><ul>
<li>let 和 const增加了块级作用域</li>
<li>ES6允许块级作用域任意嵌套</li>
<li><p>ES5不允许函数声明在块级作用域中，但是ES6允许。但是由于历史包袱，建议避免在块级作用域中声明函数语句。</p>
  <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//不推荐</span></span><br><span class="line">	<span class="comment">// 函数声明语句</span></span><br><span class="line">	&#123;</span><br><span class="line">	  let a = <span class="string">'secret'</span>;</span><br><span class="line">	  function f() &#123;</span><br><span class="line">	    <span class="keyword">return</span> a;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	```	</span><br><span class="line"><span class="preprocessor">#### const</span></span><br><span class="line"></span><br><span class="line">* <span class="keyword">const</span> 声明一个只读的常量，一旦声明，不能更改。</span><br><span class="line">* 不存在变量提升</span><br><span class="line">* 不允许重复声明</span><br><span class="line">* 暂时性死区</span><br><span class="line">* 复合类型的常量，常量名不指向数据，而是指向数据所在的地址</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 解构 Destructuring</span></span><br><span class="line">ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构</span><br><span class="line">如果解构不成功，变量的值就等于undefined。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#### 默认值</span></span><br><span class="line"></span><br><span class="line">* <span class="keyword">var</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#### 对象的解构</span></span><br><span class="line"></span><br><span class="line">* <span class="keyword">var</span> &#123; foo, bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">* 如果变量名与属性名不一致，必须写成下面这样。</span><br><span class="line"></span><br><span class="line">	&gt; <span class="keyword">var</span> &#123; foo: baz &#125; = &#123; foo: <span class="string">'aaa'</span>, bar: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">	baz <span class="comment">// "aaa"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#### 字符串的解构</span></span><br><span class="line"></span><br><span class="line">* <span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#### 数值和布尔值的解构</span></span><br></pre></td></tr></table></figure>
<p>  let {toString: s} = 123;<br>  s === Number.prototype.toString // true</p>
<p>  let {toString: s} = true;<br>  s === Boolean.prototype.toString // true</p>
  <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#### 函数形参的解构</span></span><br></pre></td></tr></table></figure>
<p>  function add([x, y]){</p>
<pre><code><span class="keyword">return</span> x + y;
</code></pre><p>  }</p>
<p>  add([1, 2]);</p>
  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="header">#### 用途</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>交换变量的值</span><br><span class="line"><span class="bullet">* </span>从函数返回多个值</span><br><span class="line"><span class="bullet">* </span>函数参数的定义</span><br><span class="line"><span class="bullet">* </span><span class="strong">__提取JSON数据__</span></span><br><span class="line"><span class="bullet">* </span>函数默认值</span><br><span class="line"><span class="bullet">* </span>遍历Map结构</span><br><span class="line"><span class="bullet">* </span><span class="strong">__输入模块的指定方法__</span></span><br><span class="line"></span><br><span class="line"><span class="header">### 字符串的扩展</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>includes()</span><br><span class="line"><span class="bullet">* </span>startsWith()</span><br><span class="line"><span class="bullet">* </span>endWith()</span><br><span class="line"><span class="bullet">* </span>模板字符串</span><br></pre></td></tr></table></figure>
<p>   <code>abs${x}</code></p>
  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="header">### 数值的扩展</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>二进制（0b）八进制（0o）表示</span><br><span class="line"><span class="bullet">* </span>Number.isFinite(obj) 是否为有限的</span><br><span class="line"><span class="bullet">* </span>Number.isNaN(obj)</span><br><span class="line"><span class="bullet">* </span>Number.isSafeNumber()</span><br><span class="line"></span><br><span class="line"><span class="header">### 数组的扩展</span></span><br><span class="line"></span><br><span class="line"><span class="header">#### Array.from()</span></span><br><span class="line"></span><br><span class="line">将类似数组对象和可遍历的对象转化为数组</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>类似数组对象：用length属性的对象</span><br><span class="line"><span class="bullet">* </span>可遍历对象： 具有Iterator接口</span><br><span class="line"><span class="bullet">* </span>扩展运算符也可以将可遍历对象转换为数组</span><br><span class="line"><span class="bullet">* </span>Array.from(obj, function)的第二个参数function作用与map类似，可以对数组进行操作，返回一个新的数组。</span><br><span class="line"></span><br><span class="line"><span class="header">#### Array.of()</span></span><br><span class="line">将一组数值，转换为数组。</span><br><span class="line"></span><br><span class="line"><span class="code">`Array.of(3, 11, 8) // [3,11,8]`</span></span><br><span class="line"></span><br><span class="line">因为数组的构造函数Array存在下列不足</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Array() // []<br>Array(3) // [, , ,]<br>Array(3, 11, 8) // [3, 11, 8]<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### <span class="built_in">array</span>#find<span class="literal">()</span></span><br><span class="line"> </span><br><span class="line"> 没有时返回undefined。</span><br><span class="line"> </span><br><span class="line">#### <span class="built_in">array</span>#includes<span class="literal">()</span></span><br><span class="line"></span><br><span class="line">#### <span class="built_in">array</span>#entries<span class="literal">()</span>, <span class="built_in">array</span>#keys<span class="literal">()</span>, <span class="built_in">array</span>#values<span class="literal">()</span></span><br><span class="line"></span><br><span class="line">keys对键遍历，values对值进行遍历，entries对键值进行遍历</span><br><span class="line"></span><br><span class="line">#### 数组的空位</span><br><span class="line"></span><br><span class="line">数组的空位指，数组的某一个位置没有任何值。不同于undefined</span><br><span class="line"></span><br><span class="line"><span class="type">ES5</span>对空位的处理很不一致</span><br><span class="line"></span><br><span class="line">* forEach<span class="literal">()</span>,filter<span class="literal">()</span>, every<span class="literal">()</span>,some都会跳过空位</span><br><span class="line">* map会跳过空位，但是会保留这个值</span><br><span class="line">* join<span class="literal">()</span>和toSting<span class="literal">()</span>会将空位视为undefined。</span><br><span class="line"></span><br><span class="line"><span class="type">ES6</span>明确将空位转为undefined。</span><br><span class="line"></span><br><span class="line">* <span class="type">Array</span>.from会将数组的空位转为undefined。</span><br><span class="line">* copyWithin<span class="literal">()</span>会连空位一起拷贝</span><br><span class="line">* fill<span class="literal">()</span>会将空位视为正常的数组位</span><br><span class="line">* <span class="keyword">for</span>...<span class="keyword">of</span>循环也会遍历空位</span><br><span class="line"></span><br><span class="line">### 对象的扩展</span><br><span class="line"></span><br><span class="line">#### 属性的简洁表示法</span><br><span class="line"><span class="type">ES6</span>允许直接写入变量和函数，作为对象的属性和方法。</span><br></pre></td></tr></table></figure></p>
<p>var foo = ‘bar’;<br>var baz = {foo};<br>baz // {foo: “bar”}</p>
<p>// 等同于<br>var baz = {foo: foo};</p>
<p>var o = {<br>  method() {<br>    return “Hello!”;<br>  }<br>};</p>
<p>// 等同于</p>
<p>var o = {<br>  method: function() {<br>    return “Hello!”;<br>  }<br>};<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#### 属性名表达式</span></span><br><span class="line">可以用表达式作为某个属性的属性名，这时表达式要放在方括号之内</span><br></pre></td></tr></table></figure></p>
<p>// 方法一<br>obj.foo = true;</p>
<p>// 方法二<br>obj[‘a’ + ‘bc’] = 123;<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>属性名表达式和简洁表示法不能同时使用</span><br></pre></td></tr></table></figure></p>
<p>// 报错<br>var foo = ‘bar’;<br>var bar = ‘abc’;<br>var baz = { [foo] };<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#### 方法的name属性</span></span><br><span class="line"></span><br><span class="line">函数的name属性，返回函数名称</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#### Object.is()</span></span><br><span class="line"></span><br><span class="line">ES5比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+<span class="number">0</span>等于-<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">ES5缺乏一种运算，在所有环境中，只要两个值是一样的，他们就相等。</span><br><span class="line"></span><br><span class="line">ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。<span class="built_in">Object</span>.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</span><br></pre></td></tr></table></figure></p>
<p>Object.is(‘foo’, ‘foo’)<br>// true<br>Object.is({}, {})<br>// false<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不同之处只有两个：一是+<span class="number">0</span>不等于-<span class="number">0</span>，二是NaN等于自身。</span><br></pre></td></tr></table></figure></p>
<p>+0 === -0 //true<br>NaN === NaN // false</p>
<p>Object.is(+0, -0) // false<br>Object.is(NaN, NaN) // true<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### <span class="built_in">Object</span>.assign()</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign方法的第一个参数是目标对象，后面的参数都是源对象。</span><br><span class="line"></span><br><span class="line">* 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</span><br><span class="line">* 由于<span class="literal">undefined</span>和<span class="literal">null</span>无法转成对象，所以如果它们作为参数，就会报错。</span><br><span class="line">* <span class="built_in">Object</span>.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用</span><br><span class="line"></span><br><span class="line">用法</span><br><span class="line">* 为属性指定默认值</span><br></pre></td></tr></table></figure></p>
<pre><code><span class="keyword">let</span> options = <span class="built_in">Object</span>.assign({}, DEFAULTS, options);
<span class="string">``</span><span class="string">`</span>
</code></pre><ul>
<li>合并多个对象</li>
<li>克隆对象</li>
<li>为对象添加方法</li>
<li>为对象添加属性</li>
</ul>
<h4 id="属性的可枚举性">属性的可枚举性</h4><p>描述对象的enumerable属性成为「可枚举性」，如果该属性为false，某些操作会忽略当前属性。</p>
<p>ES5有三个操作会忽略enumerable为false的属性</p>
<ul>
<li>for..in循环：遍历对象自身和继承的可枚举属性</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性键名</li>
<li>JSON.stringify():只串行化对象自身的可枚举属性</li>
</ul>
<p>ES6新增了一个操作</p>
<ul>
<li>Object.assign() 会忽略enumerable为false的属性，之拷贝对象自身的可枚举属性</li>
</ul>
<h4 id="属性的遍历">属性的遍历</h4><p>ES6一共有5种方法可以遍历对象的属性</p>
<ul>
<li>for..in</li>
<li>Object.key(obj)</li>
<li>Object.getOwnPropertyNames(obj)</li>
<li>Object.getOwnPropertySymbols(obj)</li>
<li>Reflect.ownKeys(obj)</li>
</ul>
<p>–<br>(1）类的实例属性</p>
<p>类的实例属性可以用等式，写入类的定义之中。</p>
<p>class MyClass {<br>  myProp = 42;</p>
<p>  constructor() {<br>    console.log(this.myProp); // 42<br>  }<br>}</p>
<p>（2）类的静态属性</p>
<p>类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。</p>
<p>class MyClass {<br>  static myStaticProp = 42;</p>
<p>  constructor() {<br>    console.log(MyClass.myProp); // 42<br>  }<br>}</p>
<p>（3） let<br>  块内临时变量</p>
<p>（4）const<br>  常量，声明后必须立即赋值 </p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="let_const">let const</h3><h4 id="let">let</h4><ul>
<li>声明临时变量，在块级作用域</li>
<li>不存在变量提升</li>
<li><p>暂时性死区</p>
<blockquote>
<p>变量必须在声明后]]>
    </summary>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangximing.github.io/2016/08/30/redux/"/>
    <id>http://wangximing.github.io/2016/08/30/redux/</id>
    <published>2016-08-30T02:38:24.000Z</published>
    <updated>2016-08-30T02:38:24.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>Action 只是描述了有事情发生了这一事实</li>
<li>reducer 指明应用如何更新 state</li>
<li>Redux 应用只有一个单一的 store</li>
<li>任何一个从 connect() 包装好的组件都可以得到一个 dispatch 方法作为组件的 props</li>
<li>connect() 的唯一参数是 selector。此方法可以从 Redux store 接收到全局的 state，然后返回给组件中的 props。</li>
<li>redux-actions 这类的辅助库来生成 action creator 和 reducer </li>
<li>Redux middleware 被用于解决不同的问题，但其中的概念是类似的。它提供的是位于 action 被发起之后，到达 reducer 之前的扩展点。</li>
</ul>
<h2 id="React">React</h2><ul>
<li>React 通过将数组中的每个元素渲染为一个节点的方式对数组进行自动求值。</li>
<li><p>JSX中不能使用if else,可以通过下面的方法解决</p>
<ul>
<li>使用三目运算符</li>
<li>设置一个变量，并在属性中引用它</li>
<li>将逻辑转换到函数中</li>
<li>使用&amp;&amp;</li>
</ul>
</li>
<li>htmlFor, className</li>
</ul>
<h4 id="声明周期">声明周期</h4><h5 id="实例化">实例化</h5><p>getDefaultProps–&gt;getInitailState–&gt;componentWillMount–&gt;render–&gt;componentDidMount</p>
<h5 id="存在期">存在期</h5><p>componentWillReceiveProps–&gt;shouldComponentUpdate–&gt;componentWillUpdate–&gt;render–&gt;componentDidUpdate</p>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>Action 只是描述了有事情发生了这一事实</li>
<li>reducer 指明应用如何更新 state</li>
<li>Redux 应用只有一个单一的 store</li>
<li>任何一个从 connect() 包装好的组件都可以得到一个 dispat]]>
    </summary>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangximing.github.io/2016/06/29/AngularJS%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://wangximing.github.io/2016/06/29/AngularJS深度剖析与最佳实践/</id>
    <published>2016-06-29T14:15:57.000Z</published>
    <updated>2016-06-29T14:15:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Angular开发技巧">Angular开发技巧</h2><h3 id="在非独立作用域指令中实现scope绑定">在非独立作用域指令中实现scope绑定</h3><p>假设我们有一个指令</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">some</span>-directive <span class="property">name</span>=<span class="string">"1+1"</span> value=<span class="string">"1+1"</span> <span class="function_start"><span class="keyword">on</span></span>-event=<span class="string">"vm.test(age)"</span>&gt;&lt;/<span class="keyword">some</span>-directive&gt;</span><br></pre></td></tr></table></figure>
<p>当我们自定义指令时，我们可以通过scope表达式来绑定。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">directive</span>(<span class="string">'someDirective'</span>, function &#123;</span><br><span class="line">	<span class="tag">return</span> &#123;</span><br><span class="line">		<span class="tag">scope</span>: &#123;</span><br><span class="line">			<span class="attribute">name</span>: <span class="string">'@'</span>,</span><br><span class="line">			<span class="attribute">value</span>: <span class="string">'='</span>,</span><br><span class="line">			<span class="attribute">onEvent</span>: '&amp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>非常的简单易懂，但这种方式有一个问题 scope: {}的形式让这个指令自动具有了独立作用域，而这将导致无法再同一个元素上使用需要作用域的指令。</p>
<p>解决办法是不使用scope绑定表达式，而是自己来达到类似的效果</p>
<p>name: attrs.name  –&gt; 字符串’1+1’</p>
<p>value： scope.$eval(attrs.value) –&gt; 数字 2</p>
<p>event: scope.$eval(attrs.onEvent, {$event: event, age: 30});</p>
<blockquote>
<p>scope.$eval()是一个函数，他可以接受两个参数，第一个是要计算的表达式，第二个是计算这个表达式时可以访问的额外的变量</p>
</blockquote>
<h3 id="在指令中让使用者自定义模板">在指令中让使用者自定义模板</h3><h3 id="阻止事件冒泡的浏览器默认行为">阻止事件冒泡的浏览器默认行为</h3><p>$event.stopPropagation()</p>
<h3 id="动态绑定HTML">动态绑定HTML</h3><p>ngBindHtml</p>
<p>通过$src.trustAsHTML来告诉Angular这是可信的</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Angular开发技巧">Angular开发技巧</h2><h3 id="在非独立作用域指令中实现scope绑定">在非独立作用域指令中实现scope绑定</h3><p>假设我们有一个指令</p>
<figure class="highlight applescr]]>
    </summary>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangximing.github.io/2016/06/28/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://wangximing.github.io/2016/06/28/ES6学习笔记/</id>
    <published>2016-06-28T13:02:26.000Z</published>
    <updated>2016-06-28T13:02:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="let,content">let,content</h2><ul>
<li>let 块级作用域</li>
<li>不变量提升，所以要先声明</li>
<li>不允许重复声明</li>
<li><p>暂时性死区</p>
<p>  只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响</p>
</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError tmp is not defined</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错</p>
<ul>
<li>函数不能声明在块级作用域中</li>
<li>const声明一个只读的常量。一旦声明，常量的值就不能改变。</li>
<li>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</li>
</ul>
<h2 id="变量的解构赋值">变量的解构赋值</h2><ul>
<li>解构 ： ES6允许通过一定模式，从数组和对象中取值，并进行赋值</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> c</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">----&gt;ES6	</span><br><span class="line"><span class="variable"><span class="keyword">var</span> [a, b, c]</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>解构赋值允许指定默认值</li>
</ul>
<h2 id="字符串的扩展">字符串的扩展</h2><ul>
<li>includes(), startsWith(), endsWith()</li>
</ul>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="keyword">startsWith</span>(<span class="string">'Hello'</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="keyword">endsWith</span>(<span class="string">'!'</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'o'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="Symbol">Symbol</h2><ul>
<li>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</li>
</ul>
<h2 id="Class">Class</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">---&gt;ES6</span><br><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(x, y) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--&gt;ES6继承</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ColorPoint extends Point &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(x, y, color) </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>
</li>
<li><p>静态方法</p>
</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">classMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mixin</li>
</ul>
<h2 id="Decorator">Decorator</h2><h2 id="严格模式">严格模式</h2><p>ES6自动采用严格模式，不论有没有加上 ‘use strict’</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用with语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能使用前缀0表示八进制数，否则报错</li>
<li>不能删除变量delete prop，会报错，只能删除属性delete global[prop]?</li>
<li>eval不会在它的外层作用域引入变量</li>
<li>eval和arguments不能被重新赋值</li>
<li>arguments不会自动反映函数参数的变化</li>
<li>禁止this指向全局对象</li>
<li>增加了保留字（比如protected、static和interface）</li>
</ul>
<h2 id="Module">Module</h2><h3 id="export">export</h3><p>规定对外的接口，必须与模块内的变量建立一一对应的关系</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line">----&gt;另一种写法</span><br><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br><span class="line"></span><br><span class="line">-----&gt;输出一个函数</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;f&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="import">import</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>import命令具有提升效果，会提升到整个模块的头部，首先执行。</li>
<li>整体导入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; area, circumference &#125; <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circumference(<span class="number">14</span>));</span><br><span class="line"></span><br><span class="line">----&gt;整体导入</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + circle.area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circle.circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="let,content">let,content</h2><ul>
<li>let 块级作用域</li>
<li>不变量提升，所以要先声明</li>
<li>不允许重复声明</li>
<li><p>暂时性死区</p>
<p>  只要块级作用域内存在let命令，它所]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript语言精粹（2）]]></title>
    <link href="http://wangximing.github.io/2016/06/22/JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B92/"/>
    <id>http://wangximing.github.io/2016/06/22/JavaScript语言精粹2/</id>
    <published>2016-06-22T03:33:45.000Z</published>
    <updated>2016-06-23T13:42:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="正则表达式">正则表达式</h2><h2 id="方法">方法</h2><h3 id="Array数组">Array数组</h3><ul>
<li><p>array.concat()  合并多个数组</p>
<p>  var c = a.concat(b);//不会改变a和b数组</p>
</li>
<li><p>array.join(separator)</p>
<p>  把array构造成字符串，默认separator为「，」</p>
</li>
<li><p>array.pop() 移除数组中的最后一个元素，并返回这个元素(被移除的元素)</p>
</li>
<li><p>array.push() 添加数据到数组，并返回数组的长度</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line"><span class="variable"><span class="keyword">var</span> b</span> = [<span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">var</span> c</span> = a.push(b, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//a [1, 2, 3, [4, 5], false]</span></span><br><span class="line"><span class="comment">//c 5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>array.reverse() 反转array的数组，并返回</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">var b = a.reverse;</span><br><span class="line"><span class="comment">//a,b 都是 [2, 1]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>array.shift() 移除并返回第一个元素</li>
<li>array.slice(start, end) 从数组中截取一段end默认为数组长度，不会改变数组。</li>
<li>array.splice(start, deleteCount, item..)。 从数组中移除元素，并用items替换。会改变元素。</li>
<li>array.sort(compareFunction) 不能正确的给数字排序。</li>
<li>array.unshift(item..)从头部插入并返回新数组的长度。</li>
</ul>
<h3 id="Function_函数">Function 函数</h3><ul>
<li><p>function.apply(this, arguments)</p>
<p>apply方法调用function，传递 this对象（上下文）和参数列表。</p>
</li>
</ul>
<h3 id="Number_数字">Number 数字</h3><ul>
<li><p>number.toExponential(小数位数)。</p>
<p>将number转换为指数形式，其中小数位数必须为0~20.</p>
</li>
<li><p>number.toFixed(小数位数) </p>
<p>  将数字转换为n为小数的字符串，小数位数默认为0， 可选范围为0~20。</p>
</li>
<li><p>number.toPrecision(percision) 把数字转换为精度为n的字符串。</p>
</li>
<li>number.toString()</li>
</ul>
<h3 id="Object_对象">Object 对象</h3><ul>
<li><p>object.hasOwnProperty(name)</p>
<p>  判断对象是否具有某属性</p>
</li>
</ul>
<h3 id="RegExp_正则表达式">RegExp 正则表达式</h3><ul>
<li><p>regexp.exec(string)</p>
<p>匹配成功将返回数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下标<span class="number">0</span>  [<span class="number">0</span>] 是匹配的字符串</span><br><span class="line">下标<span class="number">1</span>  [<span class="number">1</span>] 是第一个捕获文本</span><br><span class="line">下标<span class="number">2</span>  [<span class="number">2</span>] 是第二个捕获文本</span><br></pre></td></tr></table></figure>
</li>
<li><p>regexp.test(string) 匹配返回true，不匹配返回 false。</p>
</li>
</ul>
<h3 id="String_字符串">String 字符串</h3><ul>
<li>string.charAt(n) 返回第n个位置的字符</li>
<li>string.charCodeAt(n) 返回第n个位置的字符码</li>
<li>string.indexOf() 查找</li>
<li>string.lastIndexOf() 查找</li>
<li>string.match()</li>
<li>string.replace(serarchValue, replaceValue).</li>
<li>string.slice(start, end) 截取字符串</li>
<li>string.subString(start, end)</li>
<li><p>string.split(分隔符， limit)。</p>
<p>  将字符串分割成数组</p>
</li>
</ul>
<h2 id="糟粕">糟粕</h2><h3 id="typeOf">typeOf</h3><ul>
<li>typeOf null  //object</li>
</ul>
<h3 id="parseInt">parseInt</h3><p>指定进制，不然如果数字的第一个是0，则会基于8进制来转换</p>
<h3 id="NaN">NaN</h3><ul>
<li><p>typeOf NaN === ‘number’;</p>
</li>
<li><p>非数字转换成字符串时</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+<span class="string">'0'</span> <span class="comment">//0</span></span><br><span class="line">+<span class="string">'oops'</span> <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>NaN !== NaN //true</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="正则表达式">正则表达式</h2><h2 id="方法">方法</h2><h3 id="Array数组">Array数组</h3><ul>
<li><p>array.concat()  合并多个数组</p>
<p>  var c = a.concat(b);//不]]>
    </summary>
    
      <category term="前端" scheme="http://wangximing.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript语言精粹（1）]]></title>
    <link href="http://wangximing.github.io/2016/06/12/JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9/"/>
    <id>http://wangximing.github.io/2016/06/12/JavaScript语言精粹/</id>
    <published>2016-06-12T03:33:45.000Z</published>
    <updated>2016-06-23T13:44:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="语法">语法</h2><h3 id="标识符">标识符</h3><ul>
<li>由字母开头</li>
<li>不能使用保留字</li>
<li>JavaScript不允许在<strong>对象字面量</strong>中，或者用点运算符提取对象属相时，使用保留字作为属性名。</li>
</ul>
<h3 id="数字">数字</h3><p>只有一个数字类型，在内部被表示为64为浮点数，没有分离出整数类型。</p>
<ul>
<li>1=== 1.0</li>
<li>NaN是一个数值，它表示一个不能产生正常结果的运算结果。NaN不等于任何值，包括它自己。</li>
<li>Infinity 无穷大</li>
</ul>
<h3 id="字符串">字符串</h3><ul>
<li>JavaScript中所有字符都是16位的。</li>
<li>字符串是不可变的，一旦字符串被创建，就无法改变它。</li>
<li>两个包含着完全相同的字符切字符顺序也相同的字符串被认为是相同的字符串。  <code>&#39;a&#39; + &#39;b&#39; = &#39;ab&#39;</code></li>
</ul>
<h3 id="语句（Statements）">语句（Statements）</h3><ul>
<li>包在花括号中的语句不会创建作用域。</li>
<li>当 var语句被用字函数内部时，它定义的是这个函数的私有变量。</li>
<li><p>falsy </p>
<blockquote>
<p>false,null,undefined, ‘’, 0, NaN</p>
</blockquote>
</li>
<li><p>truly</p>
<blockquote>
<p>true, ‘false’等所有。</p>
</blockquote>
</li>
<li><p>简单的for循环</p>
</li>
<li>for..in循环<br>  for..in会枚举一个对象的所有属性名，并且通常要通过object.hasOwnProperty(variable)来约定这个属性名是该对象的成员还是来自原型链。</li>
</ul>
<h3 id="表达式（Expressions）">表达式（Expressions）</h3><ul>
<li><p>typeof的值有 ‘number’, ‘string’, ‘boolean’, ‘undefined’, ‘function’, ‘object’。</p>
<blockquote>
<ul>
<li>typeof null //object</li>
<li>type [] //object</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="字面量">字面量</h3><p>对象字面量是一种可以方面的按指定规格创建对象的表示法</p>
<ul>
<li>{}， []</li>
</ul>
<h3 id="函数_Functions">函数 Functions</h3><h2 id="对象">对象</h2><p>简单数据类型： 数字，字符串，布尔值，null，undefined</p>
<p>对象： 函数，数组，对象。</p>
<h3 id="对象字面量">对象字面量</h3><ul>
<li>{}</li>
</ul>
<h3 id="检索">检索</h3><ul>
<li>a.b</li>
<li>a[b]</li>
<li>|| 运算符可以用来填充默认值 <code>var name = a.b || &#39;Bob&#39;</code></li>
<li><p>&amp;&amp; 可以用来避免错误 </p>
<blockquote>
<ul>
<li>flight.a   //undefined</li>
<li>flight.a.b  //error</li>
<li>flight.a &amp;&amp; flight.a.b  //undefined </li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="引用">引用</h3><p>对象通过引用来传递，它们永远不会被复制</p>
<h3 id="原型">原型</h3><ul>
<li>set不会更新原型</li>
<li>get会检索原型</li>
</ul>
<h3 id="反射">反射</h3><p>原型链中的任何属性都会产生值</p>
<ul>
<li>typeof flight.toString  //function</li>
<li>typeof flight.constructor  //function</li>
</ul>
<h3 id="枚举">枚举</h3><p>for..in 语句可与来遍历一个对象的所有属性，不过要排除原型链中的属性</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(name in <span class="class"><span class="keyword">object</span>)&#123;</span></span><br><span class="line">	<span class="keyword">if</span>(typeof <span class="class"><span class="keyword">object</span>[</span>name] !== function &amp;&amp; <span class="class"><span class="keyword">object</span>.<span class="title">hasOWnProperty</span>(</span>name))&#123;</span><br><span class="line">		console.log(<span class="class"><span class="keyword">object</span>[</span>name])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>for..in属性名出现的是不固定的</li>
</ul>
<h3 id="删除">删除</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;b: <span class="string">'b'</span>, c: <span class="string">'c'</span>&#125;;</span><br><span class="line"></span><br><span class="line">delete a.b;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 减少全局变量的污染</span></span><br><span class="line"></span><br><span class="line">使用命名空间减少全局遍历的污染</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">## 函数</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 函数对象</span></span><br><span class="line"></span><br><span class="line">每个函数再创建的时候回附加两个属性，函数的上下文和实现函数行为的代码。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 函数字面量</span></span><br><span class="line"></span><br><span class="line">函数字面量创建的函数对象包含一个连接到外部的上下文，被称为闭包。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 调用</span></span><br><span class="line"></span><br><span class="line">* 函数调用时会传两个附加参数 <span class="keyword">this</span>,arguemnts。</span><br><span class="line">* 当实际参数个数比形参多时，超出的参数会被忽略。</span><br><span class="line">* 实际参数比形参少时，缺失的值会被置为undefined。</span><br><span class="line">* 四种调用模式：方法调用模式，函数调用模式，构造器调用模式，apply调用模式。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 方法调用模式</span></span><br><span class="line"></span><br><span class="line">当一个函数被保存为一个对象的属性时，成为方法。而这时的调用成为方法调用。</span><br></pre></td></tr></table></figure>
<p>var object = {<br>    value: 0;<br>    doSomething : function() {<br>        this.value = 9;<br>    }<br>}<br>object.doSometing();<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这时方法内的<span class="keyword">this</span>指的是方法所在的<span class="keyword">object</span>。所以它可以访问和修改对象的属性。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 函数调用模式</span></span><br><span class="line"></span><br><span class="line">当一个函数并非一个对象的属性时，它就是被当做函数来调用的。这时函数内的<span class="keyword">this</span>绑定的是全局对象。</span><br><span class="line"></span><br><span class="line">解决办法是把这个函数包一层并绑定到一个对象上</span><br></pre></td></tr></table></figure></p>
<p>var a = add(4, 5)<br>object.double  = function(){<br>    var that = this;<br>    var helper = function(){<br>        return add(that.a, that.b);<br>    };</p>
<pre><code>helper()<span class="comment">;</span>
</code></pre><p>}<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">### 构造器调用模式</span></span><br><span class="line"></span><br><span class="line">使用<span class="keyword">new</span>的方式调用。</span><br></pre></td></tr></table></figure></p>
<p>var Person = function(firstName) {<br>  this.firstName = firstName;<br>};</p>
<p>Person.prototype.walk = function(){<br>  console.log(“I am walking!”);<br>};</p>
<p>function Student(firstName, subject) {<br>  Person.call(this, firstName);<br>  this.subject = subject;<br>}</p>
<p>Student.prototype = Object.create(Person.prototype);</p>
<p>Student.prototype.constructor = Student;<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### apply调用模式</span></span><br><span class="line"></span><br><span class="line">函数可以拥有方法，<span class="keyword">apply</span>方法让我们传递一个参数数组给函数</span><br></pre></td></tr></table></figure></p>
<p>var array = [3, 4];<br>app.apply(null, array);<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apply 方法接受两个参数，第一个用于绑定<span class="keyword">this</span>,第二个用于传递参数。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 返回</span></span><br><span class="line"></span><br><span class="line">* 函数总会有返回值，如果没有指定则返回undefined；</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 异常</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 扩充类型的功能</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 递归</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 作用域</span></span><br><span class="line"></span><br><span class="line">* JavaScript有函数作用域，定义在函数内部的参数和变量在外部是不可见的。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 闭包（P38）</span></span><br><span class="line"></span><br><span class="line">* 作用域的好处是内部的函数可以访问定义它们的外部函数的参数和变量（除<span class="keyword">this</span>，arguments）。</span><br><span class="line">* 内部函数比外部函数有更长的生命周期。</span><br></pre></td></tr></table></figure></p>
<p>var quo = function(status) {<br>    return {<br>        get_status: function(){<br>            return status;<br>        }<br>    }<br>}</p>
<p>var myQuo = quo(‘hello’);<br>console.log(myQuo.get_status());<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">* </span>即使quo已经返回了，但get_status方法仍然享有访问quo对象status属性的权利</span><br><span class="line"><span class="bullet">* </span>get_status返回的并不是status参数的一个副本，返回的就是status属性本身。</span><br><span class="line"><span class="bullet">* </span>函数可以访问它被创建是所处的上下文，这被成为闭包。</span><br><span class="line"></span><br><span class="line"><span class="header">### 回调</span></span><br><span class="line"></span><br><span class="line"><span class="header">### 模块</span></span><br><span class="line">通过使用函数和闭包来构造模块</span><br></pre></td></tr></table></figure></p>
<p>var a = function() {<br>    var x = 9;</p>
<pre><code><span class="tag">return</span> <span class="rules">{
    <span class="rule"><span class="attribute">setX</span>:<span class="value"> <span class="function">function</span>(input) {
        x = input</span></span>;
    }</span>,
    <span class="rule"><span class="attribute">getX</span>:<span class="value"> <span class="function">function</span>() {
        return x</span></span>;
    }
}
</code></pre><p>}<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">### 级联</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 柯里化</span></span><br><span class="line"></span><br><span class="line">把函数和传递给它的参数结合，生成一个新的函数。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 记忆？？？</span></span><br><span class="line"></span><br><span class="line">函数可以将先前的操作结果记录在某个对象中，从而避免无所谓的重复计算。这种优化被称为「记忆」</span><br><span class="line"></span><br><span class="line">p44</span><br><span class="line"></span><br><span class="line">斐波那契的例子</span><br></pre></td></tr></table></figure></p>
<p>var fibonacci = function() {<br>    return n &lt; 2 ? n : fibonacci(n-1) + fibonicci(n-2);<br>}</p>
<p>for(var i = 0; i &lt;= 10; i++) {<br>    console.log(fibonacci(i));<br>}</p>
<p>fibonacci共被调用了453次，我们调用11次，本身调用442次</p>
<p>var fibonacci  = function() {<br>    var memo = [0, 1];</p>
<pre><code><span class="keyword">var</span> fib = function(n) {
    <span class="keyword">var</span> <span class="literal">result</span> = memo[n];

    <span class="keyword">if</span>(typeof <span class="literal">result</span> !== 'number') {
        <span class="literal">result</span> = fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);
        memo[n] = reuslt;
    }
    <span class="literal">result</span> <span class="literal">result</span>;
};

retuern fib;
</code></pre><p>}</p>
<p>计算29次，我们调用11次，自己调用18次。<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">## 继承</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 简介</span></span><br><span class="line"></span><br><span class="line">JavaScript是一门基于原型的语言，着意味着对象直接从其他对象继承。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 模拟基于类的继承</span></span><br></pre></td></tr></table></figure></p>
<p>var Person = function(firstName) {<br>  this.firstName = firstName;<br>};</p>
<p>Person.prototype.walk = function(){<br>  console.log(“I am walking!”);<br>};</p>
<p>function Student(firstName, subject) {<br>  Person.call(this, firstName);<br>  this.subject = subject;<br>}</p>
<p>Student.prototype = Object.create(Person.prototype);</p>
<p>Student.prototype.constructor = Student;<br>```</p>
<h3 id="函数化">函数化</h3><p>使用应用块模式来完成私有变量模式。</p>
<h3 id="部件">部件</h3><h2 id="数组">数组</h2><h3 id="数组字面量">数组字面量</h3><p>var array = [];<br>var numbers = [1, 2, 3];</p>
<ul>
<li>JS允许数组包含任意混合类型的值</li>
</ul>
<h3 id="长度">长度</h3><ul>
<li>length属性的值是这个数组的最大整数属性名加上1， 他不一定等于数组里属性的个数</li>
<li>设置更大的length不会给数组分配更多的空间，而把length设小将导致下标大于等于length的属性被删除</li>
<li>给数组追加一个值 numbers[numbers.length] = ‘hello’, numbers.push(‘hello’);</li>
</ul>
<h3 id="删除-1">删除</h3><ul>
<li><p>使用delete删除数组元素后会留下一个空洞 delete numbers[2],</p>
</li>
<li><p>使用splice删除元素，numbers.splice(start, length);</p>
</li>
</ul>
<h3 id="遍历">遍历</h3><h3 id="区别数组和对象">区别数组和对象</h3><ul>
<li><p>input &amp;&amp; typeof input === ‘object’ &amp;&amp; input.constructor === Array;</p>
<p>  但识别从不同窗口，帧构建的数组时会失败</p>
</li>
<li><p>Object.prototype.toString.apply(value) === ‘[object Array]’;//true 数组</p>
<p>  这种方式适合各种情况</p>
</li>
</ul>
<h3 id="扩展数组方法">扩展数组方法</h3><h3 id="指定初始值">指定初始值</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="语法">语法</h2><h3 id="标识符">标识符</h3><ul>
<li>由字母开头</li>
<li>不能使用保留字</li>
<li>JavaScript不允许在<strong>对象字面量</strong>中，或者用点运算符提取对象属相时，使用保留字作]]>
    </summary>
    
      <category term="前端" scheme="http://wangximing.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[前端小知识]]></title>
    <link href="http://wangximing.github.io/2016/05/12/%E5%89%8D%E7%AB%AF%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>http://wangximing.github.io/2016/05/12/前端小知识/</id>
    <published>2016-05-12T03:33:45.000Z</published>
    <updated>2016-07-21T01:51:04.000Z</updated>
    <content type="html"><![CDATA[<h3 id="HTML">HTML</h3><ul>
<li>tabel 不能设置高</li>
<li>form不能嵌套</li>
<li><p>form提交</p>
<blockquote>
<ul>
<li>If a form has only one input field then hitting enter in this field     &gt;    triggers form submit (ngSubmit)<br>如果表单只有一个input，那么在这个input中点击enter将会提交表单</li>
<li>if a form has 2+ input fields and no buttons or input[type=submit]     &gt; then     hitting enter doesn’t trigger submit<br>如果表单中有多个input，而没有button或input[type=submit]，点击enter也不会提交表单。</li>
<li>if a form has one or more input fields and one or more buttons or     &gt; input[type=submit] then hitting enter in any of the input fields will     &gt;trigger the click handler on the first button or input[type=submit]     –(ngClick) and a submit handler on the enclosing form (ngSubmit) 若表单中有若干input,和多个button/input[type=submit]。当在某个input中点击enter时，将会触发第一个button/input[type=submit]绑定的方法和ngSubmit绑定的方法。</li>
</ul>
</blockquote>
</li>
<li><p>当非float的元素和float的元素在一起的时候，如果非float元素在先，那么float的元素将被排斥也就是说，你的span是float:right，但是你文本还是float:none。</p>
</li>
<li><p>三栏布局</p>
<ul>
<li>参考<br>  <a href="http://www.zhangxinxu.com/wordpress/2009/11/%E6%88%91%E7%86%9F%E7%9F%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%89%E6%A0%8F%E7%BD%91%E9%A1%B5%E5%AE%BD%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E6%96%B9%E6%B3%95/" target="_blank" rel="external">我熟知的三栏布局</a></li>
<li><p>绝对定位法</p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"content"</span>&gt;</span><br><span class="line">	&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"left"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">	&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"main"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">	&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"right"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"></span><br><span class="line">.content &#123;</span><br><span class="line">	position: relative;</span><br><span class="line">	</span><br><span class="line">	.main &#123;</span><br><span class="line">		margin: <span class="number">0</span> <span class="number">300</span>px; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.left &#123;</span><br><span class="line">		width:<span class="number">300</span>px;</span><br><span class="line">		position: absolute;</span><br><span class="line">		left: <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.right &#123;</span><br><span class="line">		width:<span class="number">300</span>px;</span><br><span class="line">		position: absolute;</span><br><span class="line">		right: <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>* margin负值法

    中间的主体要使用双层标签。外层div宽度100%显示，并且浮动（本例左浮动，下面所述依次为基础），内层div为真正的主体内容，含有左右210像素的margin值。左栏与右栏都是采用margin负值定位的，左栏左浮动，margin-left为-100%，由于前面的div宽度100%与浏览器，所以这里的-100%margin值正好使左栏div定位到了页面的左侧；右侧栏也是左浮动，其margin-left也是负值，大小为其本身的宽度即200像素。

    <span class="comment"><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"content"</span>&gt;</span><br><span class="line">	&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"left"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">	&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"main"</span>&gt;</span><br><span class="line">		&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"body"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">	&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">	&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"right"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"></span><br><span class="line">.main, .left, .right &#123;</span><br><span class="line">	float: left;</span><br><span class="line">&#125;</span><br><span class="line">.main &#123;</span><br><span class="line">	width: <span class="number">100</span>%;</span><br><span class="line">	.body &#123;</span><br><span class="line">		margin: <span class="number">0</span> <span class="number">210</span>px;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.left &#123;</span><br><span class="line">	margin-left: -<span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right &#123;</span><br><span class="line">	margin-left: -<span class="number">200</span>px;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">.left, .right &#123;</span><br><span class="line">	width: <span class="number">200</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>


* 自身浮动法

    <span class="comment"><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"content"</span>&gt;</span><br><span class="line">	&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"left"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">	&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"main"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">	&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"right"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"></span><br><span class="line">.main &#123;</span><br><span class="line">	margin: <span class="number">0</span> <span class="number">210</span>px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left, .right &#123;</span><br><span class="line">	width: <span class="number">200</span>px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left, .main &#123;</span><br><span class="line">	float: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right &#123;</span><br><span class="line">	float: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>
</code></pre><ul>
<li>=== 比较时会先比较类型，如果类型不相等直接返回false。</li>
<li>使用 == 比较字符串和数字时会出现 0 == ‘’  //true的情况</li>
<li><code>this.options   = $.extend({}, Button.DEFAULTS, options)</code></li>
<li><a href="https://github.com/angular/angular.js/issues/11565" target="_blank" rel="external">$scope.$watch</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="HTML">HTML</h3><ul>
<li>tabel 不能设置高</li>
<li>form不能嵌套</li>
<li><p>form提交</p>
<blockquote>
<ul>
<li>If a form has only one input fiel]]>
    </summary>
    
      <category term="前端" scheme="http://wangximing.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Background]]></title>
    <link href="http://wangximing.github.io/2016/04/29/CSS_Background/"/>
    <id>http://wangximing.github.io/2016/04/29/CSS_Background/</id>
    <published>2016-04-29T03:33:45.000Z</published>
    <updated>2016-12-19T13:10:19.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>background-image: contain 伸缩图片显示到父容器， 但<strong>不会超出父容器</strong>的范围，</p>
<p>background-size: cover；伸缩图片到父容器，会<strong>充满父容器</strong>，</p>
<p>background-clip 规定了背景渲染的范围 默认为 border+padding+content,常见例子比如border的颜色和content的背景色不同。就需要设置background-clip: content-box</p>
<p>缩写的顺序 color–&gt;image–&gt;repeat–&gt;attachment–&gt;position</p>
<p>background: #ffffff url(“img_tree.png”) no-repeat right top;</p>
</blockquote>
<h3 id="CSS_Background">CSS Background</h3><ul>
<li>background</li>
<li>background-image</li>
<li>background-size</li>
<li>background-origin</li>
<li>background-clip</li>
</ul>
<h4 id="background">background</h4><p>顺序</p>
<p>color–&gt;image–&gt;repeat–&gt;attachment–&gt;position</p>
<p><code>background: #ffffff url(&quot;img_tree.png&quot;) no-repeat right top;</code></p>
<h4 id="background-image">background-image</h4><p><code>background-image: url(img_flwr.gif), url(paper.gif);</code></p>
<p>也可以使用background代替</p>
<p><code>background: url(img_flwr.gif) right bottom no-repeat, url(paper.gif) left top repeat;</code></p>
<h4 id="background-size">background-size</h4><p><code>background-size: 100px 80px;</code></p>
<p>background-size: contain； 伸缩图片显示到父容器， 但<strong>不会超出父容器</strong>的范围，所以父容器的有些地反不会被覆盖到。</p>
<p>background-size: cover； 伸缩图片到父容器，会<strong>充满父容器</strong>，所以可能不会把图片的全部内容都显示出来。</p>
<h4 id="background-clip">background-clip</h4><p>指定背景渲染的范围</p>
<ul>
<li>border-box–(default) 图片显示的范围 border+padding+content</li>
<li>padding-box–图片显示的范围 padding + content</li>
<li>content-box–图片显示范围 content</li>
</ul>
<h4 id="background-origin">background-origin</h4><p>指定背景图开始的位置</p>
<ul>
<li>border-box–从border的左上角落位置开始</li>
<li>padding-box–(default) 从padding的左上角落位置开始</li>
<li>content-box–从content的左上角落位置开始</li>
</ul>
<h4 id="background-color">background-color</h4><h4 id="background-repeat">background-repeat</h4><ul>
<li>repeat(default)</li>
<li>repeat-x</li>
<li>repeat-y</li>
<li>no-repeat</li>
</ul>
<h4 id="background-attachment">background-attachment</h4><p>设置背景图片是fixed还是scrolls</p>
<ul>
<li>scroll(default)–The background scrolls along with the element. This is default</li>
<li>fixed –The background is fixed with regard to the viewport</li>
<li>local –The background scrolls along with the element’s contents</li>
</ul>
<h4 id="background-position">background-position</h4><p>规定了图片开始的位置</p>
<p>如果以left top指定了位置，其默认值为center</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">left</span> <span class="attribute">top</span></span><br><span class="line"><span class="attribute">left</span> <span class="value">center</span></span><br><span class="line"><span class="attribute">left</span> <span class="attribute">bottom</span></span><br><span class="line"><span class="attribute">right</span> <span class="attribute">top</span></span><br><span class="line"><span class="attribute">right</span> <span class="value">center</span></span><br><span class="line"><span class="attribute">right</span> <span class="attribute">bottom</span></span><br><span class="line"><span class="value">center</span> <span class="attribute">top</span></span><br><span class="line"><span class="value">center</span> <span class="value">center</span></span><br><span class="line"><span class="value">center</span> <span class="attribute">bottom</span></span><br><span class="line"></span><br><span class="line">x% y%</span><br><span class="line"></span><br><span class="line">xpos ypos</span><br></pre></td></tr></table></figure>
<h3 id="问题">问题</h3><ul>
<li>background-position 指定了<strong>图片</strong>开始的位置，Sets the starting position of a background image</li>
<li>background-clip –painting area of the background.</li>
<li>background-origin –specifies where the background image is positioned.</li>
</ul>
<p><strong>这三个的分别怎么用？</strong></p>
<ul>
<li>参考 <a href="http://www.cnblogs.com/2050/archive/2012/11/13/2768289.html" target="_blank" rel="external">http://www.cnblogs.com/2050/archive/2012/11/13/2768289.html</a></li>
<li>background-clip规定了border，padding等是否显示背景<ul>
<li>若显示背景且背景存在，则显示</li>
<li>若不显示背景，不管背景存不存在，都不显示</li>
</ul>
</li>
<li>background-origin 规定了开始绘制背景的原点</li>
<li>background-positon 规定了背景相对于background-origin的位置，center left等。</li>
</ul>
<p>总结来看就是 background-origin和background-positon规定了背景的位置。而background-clip规定了其可显示的范围</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>background-image: contain 伸缩图片显示到父容器， 但<strong>不会超出父容器</strong>的范围，</p>
<p>background-size: cover；伸缩图片到父容器，会<strong>充满父容器</s]]>
    </summary>
    
      <category term="CSS Background" scheme="http://wangximing.github.io/tags/CSS-Background/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS 规范]]></title>
    <link href="http://wangximing.github.io/2016/04/23/css%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://wangximing.github.io/2016/04/23/css代码规范/</id>
    <published>2016-04-23T03:33:45.000Z</published>
    <updated>2016-05-12T10:21:58.000Z</updated>
    <content type="html"><![CDATA[<h3 id="css_顺序">css 顺序</h3><ul>
<li>position</li>
<li>display/box model</li>
<li>others</li>
</ul>
<h3 id="一份规划良好的_CSS_应当按照如下排列：">一份规划良好的 CSS 应当按照如下排列：</h3><ul>
<li>Reset 万物之根源</li>
<li>元素类型 没有 class 的 h1、ul 等</li>
<li>对象以及抽象内容 最一般、最基础的设计模式</li>
<li>子元素 由对象延伸出来的所有拓展及其子元素</li>
<li>修补 针对异常状态</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="css_顺序">css 顺序</h3><ul>
<li>position</li>
<li>display/box model</li>
<li>others</li>
</ul>
<h3 id="一份规划良好的_CSS_应当按照如下排列：">一份规划良好的 CS]]>
    </summary>
    
      <category term="CSS Background" scheme="http://wangximing.github.io/tags/CSS-Background/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解HTTPS]]></title>
    <link href="http://wangximing.github.io/2016/03/16/https/"/>
    <id>http://wangximing.github.io/2016/03/16/https/</id>
    <published>2016-03-16T08:33:45.000Z</published>
    <updated>2016-03-19T06:20:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="理解HTTPS">理解HTTPS</h2><h3 id="为什么需要HTTPS">为什么需要HTTPS</h3><p>http协议是明文传输的，这样的话:</p>
<ul>
<li>介于发送端和接收端的任何第三方节点都是可以看到传输的内容（窃听风险）</li>
<li>第三方节点可以篡改消息内容（篡改风险）</li>
<li>并且这些中间节点可以获取你的用户名和密码，伪造为你和服务器通讯，或者伪造成服务器和你通讯（冒充风险）</li>
</ul>
<p>对于冒充风险，即使你对用户名和密码进行加密。但是这些中间节点依然可以转发你的认证信息同服务器进行通讯。这样是不是很可怕呢？</p>
<p>从上面的描述中，我们可以得出使用HTTP进行传输有两个问题</p>
<ul>
<li>传输内容是明文的</li>
<li>传输内容可以被修改</li>
<li>服务器不知道发送请求的是不是真的用户，用户也不知道响应请求的是不是真的服务器</li>
</ul>
<h3 id="简介">简介</h3><p>HTTPS是<code>Hyper Text Transfer Protocol over Secure Socket Layer</code>的缩写，意思是安全的HTTP，但是为什么就安全了呢？从上面的描述可以知道，要做到安全，就要做到两件事情。</p>
<ul>
<li>对传输内容进行加密</li>
<li>防止传输内容被修改，或者内容被修改后能够被通讯的另一方知道</li>
<li>让用户知道自己是再和真的服务器进行通讯，让服务器知道和自己通讯的是真的用户</li>
</ul>
<h3 id="加密传输">加密传输</h3><h4 id="常见的加密手段有两种">常见的加密手段有两种</h4><ul>
<li><p>对称加密</p>
<p>  对称加密的意思就是说，加密和解密都用的是同一个秘钥。这样做的<strong>好处</strong>是加密效率非常高，但是<strong>坏处</strong>是秘钥要要保证没有泄露。对于有多个数据交换的个体，两两之间需要分配并维护一把秘钥，这个带来的成本是不可接受的。</p>
</li>
<li><p>非对称加密（公开秘钥加密）</p>
<ul>
<li>非对称加密的意思就是，加密用的公钥（私钥）和解密用的私钥（公钥）是不一样的</li>
<li>公钥的意思就是公开的秘钥，一般由网站用户使用</li>
<li>私钥的意思就是非公开的秘钥，一般由网站管理员持有</li>
</ul>
</li>
</ul>
<p>一般情况下，用公钥加密的数据，只有用私钥才能解开。<strong>用私钥加密的数据，只有用公钥才能解开</strong>。</p>
<p>那么HTTPS采用何种加密的方式呢？</p>
<ul>
<li><p>对称加密？</p>
<p>  前面已经提到，对称加密的坏处是对于多个数据交换的个体，两两之间需要分配并维护一把密钥。这样做的话成本太高，所以是不采用的。</p>
</li>
<li><p>非对称加密？</p>
<p>  非对称加密看起来很安全，但是它也存在一个问题。用私钥加密的数据可以用公钥解开，而公钥是公开的！</p>
<p>  举个登录例子：XX网站使用非对称加密的方式对传输内容进行加密，浏览器端拥有公钥，服务器端拥有私钥。小花打开网站输入用户名和密码登录，浏览器会对用户名和密码用公钥进行加密传输到服务器端，服务器通过私钥解密。验证身份后，将小花的个人信息通过私钥加密并返回给小花（浏览器）。</p>
<ul>
<li>浏览器端小花的用户名密码–&gt;公钥加密–&gt;服务器–&gt;私钥解密</li>
<li>服务器端小花的个人信息–&gt;私钥加密–&gt;浏览器–&gt;公钥解密</li>
</ul>
</li>
</ul>
<p>注意公钥是公开的，那就意味着小花的个人信息可以被任意的中间节点解密！</p>
<h4 id="HTTPS的加密方式">HTTPS的加密方式</h4><p>通过上面的描述可以看到，对称加密和非对称加密都不适合用来做传输的加密。哪HTTPS究竟使用的那种加密方式呢，答案就是SSL/TLS协议。也就是HTTPS中的S。</p>
<p>SSL(Secure Sockets Layer)安全套接字层。用来在HTTP到TCP/UDP之间加密</p>
<blockquote>
<p>HTTP–&gt;TCP/UDP明文传输  ===&gt;   HTTP–&gt;SSL/TLS加密–&gt;TCP/UDP密文传输。</p>
</blockquote>
<p>SSL采用的是非<strong>对称加密+对称加密</strong>的方式来对传输内容加密的。</p>
<p>简单的讲SSL/TLS的加密方式就是：</p>
<ul>
<li>小花访问XX网站，得到了公钥A</li>
<li>浏览器随机生成一个只有自己知道的对称密钥B，用公钥A加密。传给XX网站</li>
<li>XX通过私钥解密拿到对称密钥B</li>
<li>之后的通信都通过密钥B来加密</li>
</ul>
<p>这样就解决了窃听风险</p>
<p>SSL发展历史</p>
<blockquote>
<ul>
<li>1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。</li>
<li>1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。</li>
<li>1996年，SSL 3.0版问世，得到大规模应用。</li>
<li>1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。</li>
<li>2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。</li>
</ul>
</blockquote>
<h3 id="防止内容被篡改">防止内容被篡改</h3><p>这里就要引入摘要和数字签名的概念</p>
<ul>
<li><strong>摘要</strong>就是对传输的内容通过某种HASH算法计算出固定长度的内容（类似文章摘要）。</li>
<li><strong>数字签名</strong> 就是对摘要用密钥进行加密，得到的内容就是数字签名</li>
</ul>
<p>传输内容–&gt;HASH算法得到固定长度的内容–&gt;摘要–&gt;密钥加密–&gt;数字签名</p>
<p>所以在传输中，只需对传输的内容通过<strong>某种HASH算法</strong>得到摘要，并通过服务器的<strong>私钥</strong>进行加密得到<strong>数字签名</strong>。并将<strong>数字签名</strong>，和<strong>HASH算法</strong>也传到前端。然后前端通过该HASH算法的到<strong>摘要A</strong>，并与通过<strong>公钥</strong>解密数字签名后的<strong>摘要B</strong>对比，就可以判断出传输内容是否被修改。</p>
<h3 id="确定身份">确定身份</h3><p>确定身份就是让浏览器知道自己收到的请求是用户自己发送的(非第三方节点)，让用户知道自己收到的响应是服务器自己发的（非第三方节点）。</p>
<p>像登录时使用短信验证码，或者是谷歌验证器这种方式都是服务器确定登录的就是用户本身。这种验证方式采用的思想就是使用一种非浏览器传输（浏览器和服务器中间的第三方就不能获取）的方式，来做的这种确认。</p>
<p>HTTPS是如何做的呢？</p>
<h4 id="证书">证书</h4><p>证书就相当于一个网站的身份证，当用户通过HTTPS访问XX网站的时候，会先从网站上获取XX网站的证书，这时用户就知道了和自己通讯的真的是XX，而不是第三方节点。</p>
<p>证书是由CA（Certificate Authority，权威机构）颁发的，CA是一个被信任的第三方机构。</p>
<p>证书是明文传授的，所以存在几个问题：</p>
<ul>
<li>证书是伪造的</li>
<li>证书被篡改</li>
</ul>
<p>解释上面的问题，就要先了解下证书的结构。</p>
<blockquote>
<ul>
<li>颁发证书机构的名称（哪个CA）</li>
<li>证书内容本身的数字签名（CA的密钥加密）</li>
<li>证书摘要使用的HASH算法</li>
<li>证书的公钥</li>
</ul>
</blockquote>
<ul>
<li><p>证书是伪造的</p>
<p>  浏览器读取证书的颁发机构的名称，和浏览器内置的受信任的CA列表进行对比，发现是不受信任的证书。就会被认定为危险。</p>
</li>
<li><p>证书内容被伪造</p>
<p>  证书内容被伪造（包括颁发证书的机构名称， 数字签名等所有内容），根据<strong>防止内容被篡改</strong>中讲的内容，利用证书的签名，HASH算法和公钥可以判断出内容被修改。就会被认定为危险。</p>
</li>
</ul>
<p>现在解决的<strong>窃听风险， 篡改风险，冒充风险</strong>，数据就可以安全的传输了，但是还有一些小问题，<br>如证书是怎么到浏览器的和其他的比较细节步骤，HTTPS是怎么做的呢？</p>
<p>HTTPS有一个<strong>握手流程</strong>，在这个过程中的数据全部是明文传输的，然后协商出一个对称密钥为后面的具体通讯加密。</p>
<pre><code>&gt;  <span class="comment">访问XX</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">HTTPS握手</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">协商出对称密钥</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">开始加密传输</span>
</code></pre><h3 id="HTTPS握手">HTTPS握手</h3><p><a href="image/https-shake-hands.png">HTTPS握手</a></p>
<ul>
<li><p>客户端发出请求,请求包含</p>
<blockquote>
<ul>
<li>支持的协议版本，比如TLS 1.0版。</li>
<li>一个客户端生成的随机数，稍后用于生成”对话密钥”。</li>
<li>支持的加密方法，比如RSA公钥加密。</li>
<li>支持的压缩方法。</li>
</ul>
</blockquote>
</li>
<li><p>服务器回应,回应包含</p>
<blockquote>
<ul>
<li>确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</li>
<li>一个服务器生成的随机数，稍后用于生成”对话密钥”。</li>
<li>确认使用的加密方法，比如RSA公钥加密。</li>
<li>服务器证书。</li>
</ul>
</blockquote>
</li>
<li><p>客户端回应</p>
<blockquote>
<ul>
<li>一个随机数。该随机数用服务器公钥加密，防止被窃听。</li>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>
<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</li>
</ul>
</blockquote>
</li>
<li><p>服务器最后的回应</p>
<blockquote>
<ul>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>
<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="参考链接">参考链接</h3><ul>
<li><a href="https://segmentfault.com/a/1190000004523659" target="_blank" rel="external">HTTPS科普扫盲帖</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">SSL/TLS协议运行机制的概述<br>–阮一峰</a></li>
</ul>
<h3 id="证书的格式">证书的格式</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 证书版本号<span class="params">(Version)</span></span><br><span class="line">版本号指明X.<span class="number">509</span>证书的格式版本，现在的值可以为:</span><br><span class="line">    <span class="number">1</span>) <span class="number">0</span>: v1</span><br><span class="line">    <span class="number">2</span>) <span class="number">1</span>: v2</span><br><span class="line">    <span class="number">3</span>) <span class="number">2</span>: v3</span><br><span class="line">也为将来的版本进行了预定义</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 证书序列号<span class="params">(Serial Number)</span></span><br><span class="line">序列号指定由CA分配给证书的唯一的<span class="string">"数字型标识符"</span>。当证书被取消时，实际上是将此证书的序列号放入由CA签发的CRL中，</span><br><span class="line">这也是序列号唯一的原因。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 签名算法标识符<span class="params">(Signature Algorithm)</span></span><br><span class="line">签名算法标识用来指定由CA签发证书时所使用的<span class="string">"签名算法"</span>。算法标识符用来指定CA签发证书时所使用的:</span><br><span class="line">    <span class="number">1</span>) 公开密钥算法</span><br><span class="line">    <span class="number">2</span>) hash算法</span><br><span class="line">example: sha256WithRSAEncryption</span><br><span class="line">须向国际知名标准组织<span class="params">(如ISO)</span>注册</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. 签发机构名<span class="params">(Issuer)</span></span><br><span class="line">此域用来标识签发证书的CA的X.<span class="number">500</span> DN<span class="params">(DN-Distinguished Name)</span>名字。包括:</span><br><span class="line">    <span class="number">1</span>) 国家<span class="params">(C)</span></span><br><span class="line">    <span class="number">2</span>) 省市<span class="params">(ST)</span></span><br><span class="line">    <span class="number">3</span>) 地区<span class="params">(L)</span></span><br><span class="line">    <span class="number">4</span>) 组织机构<span class="params">(O)</span></span><br><span class="line">    <span class="number">5</span>) 单位部门<span class="params">(OU)</span></span><br><span class="line">    <span class="number">6</span>) 通用名<span class="params">(CN)</span></span><br><span class="line">    <span class="number">7</span>) 邮箱地址</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>. 有效期<span class="params">(Validity)</span></span><br><span class="line">指定证书的有效期，包括:</span><br><span class="line">    <span class="number">1</span>) 证书开始生效的日期时间</span><br><span class="line">    <span class="number">2</span>) 证书失效的日期和时间</span><br><span class="line">每次使用证书时，需要检查证书是否在有效期内。</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>. 证书用户名<span class="params">(Subject)</span></span><br><span class="line">指定证书持有者的X.<span class="number">500</span>唯一名字。包括:</span><br><span class="line">    <span class="number">1</span>) 国家<span class="params">(C)</span></span><br><span class="line">    <span class="number">2</span>) 省市<span class="params">(ST)</span></span><br><span class="line">    <span class="number">3</span>) 地区<span class="params">(L)</span></span><br><span class="line">    <span class="number">4</span>) 组织机构<span class="params">(O)</span></span><br><span class="line">    <span class="number">5</span>) 单位部门<span class="params">(OU)</span></span><br><span class="line">    <span class="number">6</span>) 通用名<span class="params">(CN)</span></span><br><span class="line">    <span class="number">7</span>) 邮箱地址</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>. 证书持有者公开密钥信息<span class="params">(Subject Public Key Info)</span></span><br><span class="line">证书持有者公开密钥信息域包含两个重要信息:</span><br><span class="line">    <span class="number">1</span>) 证书持有者的公开密钥的值</span><br><span class="line">    <span class="number">2</span>) 公开密钥使用的算法标识符。此标识符包含公开密钥算法和hash算法。</span><br><span class="line"><span class="number">8</span>. 扩展项<span class="params">(extension)</span></span><br><span class="line">X.<span class="number">509</span> V3证书是在v2的基础上一标准形式或普通形式增加了扩展项，以使证书能够附带额外信息。标准扩展是指</span><br><span class="line">由X.<span class="number">509</span> V3版本定义的对V2版本增加的具有广泛应用前景的扩展项，任何人都可以向一些权威机构，如ISO，来</span><br><span class="line">注册一些其他扩展，如果这些扩展项应用广泛，也许以后会成为标准扩展项。</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>. 签发者唯一标识符<span class="params">(Issuer Unique Identifier)</span></span><br><span class="line">签发者唯一标识符在第<span class="number">2</span>版加入证书定义中。此域用在当同一个X.<span class="number">500</span>名字用于多个认证机构时，用一比特字符串</span><br><span class="line">来唯一标识签发者的X.<span class="number">500</span>名字。可选。</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>. 证书持有者唯一标识符<span class="params">(Subject Unique Identifier)</span></span><br><span class="line">持有证书者唯一标识符在第<span class="number">2</span>版的标准中加入X.<span class="number">509</span>证书定义。此域用在当同一个X.<span class="number">500</span>名字用于多个证书持有者时，</span><br><span class="line">用一比特字符串来唯一标识证书持有者的X.<span class="number">500</span>名字。可选。</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>. 签名算法<span class="params">(Signature Algorithm)</span></span><br><span class="line">证书签发机构对证书上述内容的签名算法</span><br><span class="line">example: sha256WithRSAEncryption</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>. 签名值<span class="params">(Issuer's Signature)</span></span><br><span class="line">证书签发机构对证书上述内容的签名值</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="理解HTTPS">理解HTTPS</h2><h3 id="为什么需要HTTPS">为什么需要HTTPS</h3><p>http协议是明文传输的，这样的话:</p>
<ul>
<li>介于发送端和接收端的任何第三方节点都是可以看到传输的内容（窃听风险）</li>
<]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[XHR 实践]]></title>
    <link href="http://wangximing.github.io/2016/03/10/xhr/"/>
    <id>http://wangximing.github.io/2016/03/10/xhr/</id>
    <published>2016-03-10T08:33:45.000Z</published>
    <updated>2016-03-10T14:33:09.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li><strong>跨域</strong>：浏览器在全局层面禁止了页面在加载或执行与自身来源不同的域的任何脚本。</li>
</ul>
<h3 id="使用JSONP">使用JSONP</h3><p>jsonp的原理是通过<script>标签发起一个GET请求来取代XHR请求。JSONP生成一个<script>标签并插入到DOM中，然后浏览器会接管并向src属性所指向的地址发送请求。</p>
<h3 id="使用CORS">使用CORS</h3><ul>
<li>CORS （跨域资源共享，Corss Origin Resource Sharing）</li>
</ul>
<h3 id="使用代理服务器">使用代理服务器</h3></script></p>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><strong>跨域</strong>：浏览器在全局层面禁止了页面在加载或执行与自身来源不同的域的任何脚本。</li>
</ul>
<h3 id="使用JSONP">使用JSONP</h3><p>jsonp的原理是通过<script>标签发起一个GET请求来取代]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[ASCII, Unicode, JavaScript encode]]></title>
    <link href="http://wangximing.github.io/2016/03/09/JavaScript-encode/"/>
    <id>http://wangximing.github.io/2016/03/09/JavaScript-encode/</id>
    <published>2016-03-09T08:33:45.000Z</published>
    <updated>2016-03-22T13:34:12.000Z</updated>
    <content type="html"><![CDATA[<p>ASCII，Unicode都是一种字符集。</p>
<p>在了解字符集之前，得先了解下计算机中的字节的概念。</p>
<p>在计算机内部，所有的信息最终都表示为一个二进制的串。 而一个二进制<strong>位</strong>（bit）有0，1两个状态，因此8各二进制位就可以组合出256种状态，这被称为一个字节（byte）。数据存储大多以<strong>字节</strong>为单位，数据传输以<strong>位</strong>为单位。后文中出现的<strong>字符</strong>都表示一个字。</p>
<p>一种状态可以表示一个符号，那么一个字节可以表示256种符号。</p>
<h2 id="ASCII">ASCII</h2><h3 id="ASCII码">ASCII码</h3><p>为了在电脑上显示文字，就得把二进制的字符（01010010）与符号（a,A）一一对应起来。上世纪60年代，美国制定了一套字符集，把英语字符（阿拉伯字符）和二进制之间的对应关系，做了统一的规定。这被称为ASCII码（American Standard Code for Information Interchange）。</p>
<p>ASCII码一共规定了128个字符的集，比如说空格『SPACE』的十进制是32（二进制00100000），大写字母A的十进制是65（二进制01000001）。这128个符号（包括32各不能打印出来的控制符号，DEL，ESC等），只占用了一个字节的后面7位，最前面的1位统一规定为0。</p>
<h3 id="Extended_ASCII_Codes">Extended ASCII Codes</h3><p>ASCII码能表示的只有英语字母，符号和一些控制字符，所以IANA更喜欢称之为US-ASCII。</p>
<p>当到了欧洲一些国家的文字的时候，ASCII是不能表示的，比如说希腊字母，图示，制图符号£，±等。所以出现了对ASCII码的扩展。</p>
<p>不同的国家，需要显示的字符不同，对ACSII的扩展就不同，比如130在法语编码中代表é，在希伯来编码中却代表（ג），再所有的这些编码中，0-127表示的符号都是相同的，不同的只有128-255这一段。</p>
<p>这样子看起来，虽然不同的扩展比较混乱，但是编码的问题总归是解决了。但是的当到了亚洲国家的时候，ASCII码就不能胜任了，举个例子，汉字多达10万，ASCII使用一个字符，只能表示256个字符，肯定是不够用的，这个时候就必须使用多个字节表示一个字符。比如简体中文常见的编码方式是GB2312，使用两个字节编码。</p>
<p>到这里我们可以看到很多不同的编码，英语国家使用ASCII进行编码，欧洲国家对ACSII码进行了各种扩展，法国扩展、俄国扩展等。亚洲国家就可能需要用两个字节来编码。</p>
<p>有这么多编码方式，就可以解释为什么我们会看到乱码的字符，我用GB2312编码了文章A，传输到你的电脑，你用的文本编辑器却选择了ASCII编码方式打开，结果就看到了一对的乱码。</p>
<p>这里就暴漏了不同语言使用不同编码方式的两个弊端</p>
<ul>
<li>对相同的二进制编码的对应符号不同</li>
<li>找不到某些二进制编码对应的符号</li>
</ul>
<p>在这里就要问了。有没有一种编码方式，囊括了世界上所有的文字，这样就可以解决上面碰到的那个问题，答案是UTF-8。2007年，UTF-8全面超越ASCII成为最常用的编码方式，更好的是UTF-8是对ASCII码完全兼容的。</p>
<blockquote>
<p>ASCII was the most common character encoding on the World Wide Web until December 2007, when it was surpassed by UTF-8, which is fully backward compatible to ASCII.</p>
</blockquote>
<h2 id="Unicode">Unicode</h2><p>Unicode字符集可以表述几乎世界上所有的字符集，每个符号都有对应的码点（code point），每个码点对应唯一的一个字符。比如U+0639表示阿拉伯字母Ain,U+0041表示英语的大写字母A。</p>
<h3 id="Unicode的问题">Unicode的问题</h3><p>Unicode想要囊括所有的字符，所以要有更大的集合，Unicode需要4个字节的长度来进行与字符间的映射。</p>
<p>这就造成了一个问题，ASCII码表示A只需要一个字节，而Unicode的编码可能需要4个字节，而且4个字节的前三个都是浪费的。一个普通的文本，使用Unicode（UTF-32）编码要比ASCII大出3倍，这个是不可接受的。</p>
<p>问题的结果就是：</p>
<ul>
<li>Unicode很长一段时间内都没法推广</li>
<li>出现了很多种的Unicode编码方式</li>
</ul>
<h3 id="Unicode的编码">Unicode的编码</h3><p>Unicode只规定了Unicode的码点（code point），到底用什么样的字节来表示这个码点，就到了Unicode的编码问题</p>
<p>最直观的编码方式就是每个码点用四个字节表示（码点为32位二进制串），这种方法叫UTF-32。</p>
<p>UTF-8是一种变长的编码方法，字符长度从1个字节到4个字节不等。越是常用的字符，字节越短，最前面的128个字符，只使用1个字节表示，与ASCII码完全相同。</p>
<p>UTF-16编码介于UTF-32与UTF-8之间，同时结合了定长和变长两种编码方法的特点。</p>
<h3 id="UTF-8">UTF-8</h3><p>互联网的普及，将全世界的人们都连接在了一起，这时候就需要一种统一的字符集。Unicode当之无愧的抗下了这个重任，而其中，使用最广泛的一种Unicode的实现方式是UTF-8</p>
<blockquote>
<p>Unicode只是一个字符集，UTF-8 是Unicode的一种实现方式，是Unicode多种编码方式的一种。Unicode还有其他的存储方式如UTF-16,UTF-32等。</p>
</blockquote>
<p>UTF-8最大的特点就是它是一种编程的编码方式，它使用1个/多个字节表示一个符号，根据不同的字符变化字节长度。</p>
<p>UTF-8的编码规则</p>
<ul>
<li>对于单字节的字符，字节的第一位设为0，后面7位为这字符的Unicode码。因此对于英语字母，UTF-8编码和ASCII码是完全相同的。</li>
<li>对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，来表述这个符号的unicode码。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Unicode符号范围(十六进制) | UTF-<span class="number">8</span>编码方式（二进制）</span><br><span class="line">--------------------|---------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>   -   <span class="number">0000</span> <span class="number">007F</span> | <span class="number">0</span>xxxxxxx</span><br><span class="line"><span class="number">0000</span> <span class="number">0080</span>   -   <span class="number">0000</span> <span class="number">07F</span>F | <span class="number">110</span>xxxxx <span class="number">10</span>xxxxxx</span><br><span class="line"><span class="number">0000</span> <span class="number">0800</span>   -   <span class="number">0000</span> FFFF | <span class="number">1110</span>xxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx</span><br><span class="line"><span class="number">0001</span> <span class="number">0000</span>   -   <span class="number">001F</span> FFFF | <span class="number">11110</span>xxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx</span><br></pre></td></tr></table></figure>
<p>跟据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。</p>
<p>下面，还是以汉字”严”为例，演示如何实现UTF-8编码。</p>
<p>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101”，转换成十六进制就是E4B8A5。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*      <span class="number">100</span>   <span class="number">111000</span>   <span class="number">100101</span></span><br><span class="line">* <span class="number">1110</span>xxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx</span><br><span class="line">* <span class="number">11100100</span> <span class="number">10111000</span> <span class="number">10100101</span></span><br></pre></td></tr></table></figure>
<h2 id="UTF-16">UTF-16</h2><p>基本字符（基本平面）占两个字节，辅助字节（辅助平面）占四个字节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000</span> -- <span class="number">0xFFFF</span>   两个字节</span><br><span class="line"><span class="number">0x010000</span> --<span class="number">0x10FFFF</span>  四个字节</span><br></pre></td></tr></table></figure>
<h2 id="JavaScript编码">JavaScript编码</h2><p>JavaScript使用的是Unicode字符集，而且只有一种编码方式，一般理解的是JavaScript使用的编码格式是UTF-16，但事实是JavaScript使用的是UCS-2编码方式。</p>
<p>UCS-2编码方式可以理解成UTF-16的一个子集，它只包含UTF-16的前半部分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000</span> -- <span class="number">0xFFFF</span>   两个字节</span><br></pre></td></tr></table></figure>
<p>也就是说UCS-2只认识2个字节的字符，如果一个字符是四个字节，在JS中就会被认作是2个字符。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'#'</span>.<span class="built_in">length</span> = <span class="number">1</span>;</span><br><span class="line"><span class="string">'𝌆'</span>.<span class="built_in">length</span> == <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>有时候需要判断一段中英混合的文章中的字节长度。这时候比较简单的做法就是如果某个字符的码点在<br>0x0021–0x007E（英文标点和字母的范围）之间算1个字节，其余的算2个字节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i= <span class="number">0</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">      var <span class="keyword">char</span> = input.charCodeAt(i);</span><br><span class="line">      <span class="keyword">if</span>((<span class="keyword">char</span> &gt; <span class="number">0x0001</span> &amp;&amp; <span class="keyword">char</span> &lt;= <span class="number">0x007e</span>)) &#123;</span><br><span class="line">        charLength += <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        charLength += <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考链接">参考链接</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">字符编码笔记：ASCII，Unicode和UTF-8–阮一峰</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="external">Unicode与JavaScript详解–阮一峰</a></li>
<li><a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="external">ASCII Wiki</a></li>
<li><a href="http://www.asciitable.com/" target="_blank" rel="external">ASCII Table</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unicode" target="_blank" rel="external">Unicode Wiki</a></li>
<li><a href="http://unicode-table.com/en//#" target="_blank" rel="external">Unicode Table</a></li>
<li><a href="http://www.qqxiuzi.cn/zh/hanzi-unicode-bianma.php" target="_blank" rel="external">汉字 Unicode 编码范围</a></li>
<li><a href="http://www.rrn.dk/the-difference-between-utf-8-and-unicode/" target="_blank" rel="external">the-difference-between-utf-8-and-unicode</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>ASCII，Unicode都是一种字符集。</p>
<p>在了解字符集之前，得先了解下计算机中的字节的概念。</p>
<p>在计算机内部，所有的信息最终都表示为一个二进制的串。 而一个二进制<strong>位</strong>（bit）有0，1两个状态，因此8各二进制位就可]]>
    </summary>
    
      <category term="ASCII, Unicode, JavaScript encode" scheme="http://wangximing.github.io/tags/ASCII-Unicode-JavaScript-encode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Angular Conncet with Server]]></title>
    <link href="http://wangximing.github.io/2016/03/08/Angular-connect-with-server/"/>
    <id>http://wangximing.github.io/2016/03/08/Angular-connect-with-server/</id>
    <published>2016-03-08T08:33:45.000Z</published>
    <updated>2016-03-10T14:06:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Angular_Conncet_with_Server">Angular Conncet with Server</h2><p>Angular与服务器通过<code>$http</code>通信。$http 服务简单的封装了浏览器原生的XMLHttpRequest对象。<br>在Angular中，可以通过使用 <code>$http</code>, <code>$resource</code>, <code>Restangular</code>与服务器交互。</p>
<h3 id="$http">$http</h3><p>$http返回一个promise对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = $http(&#123;method: <span class="string">'GET'</span>, url: <span class="string">'/api/users'</span>, params: &#123;&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p><code>$http</code>还提供了一些快捷方法$http.get(),$http.delete()等。</p>
<h3 id="$resource">$resource</h3><p>Angular 提供了一个 <code>$resource</code> 服务，用于创建资源对象，我们可以用$resource 方便的与 RESTful的服务端进行交互。</p>
<p>$resource的参数为$resourec(‘url’, {paramDefaults}, {actions})</p>
<h4 id="定义一个resource">定义一个resource</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">var</span> Users = $resource(<span class="string">'/api/users/:id'</span>, &#123;id: <span class="string">'@id'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单使用</span></span><br><span class="line">Users.get(); <span class="comment">//get users list</span></span><br><span class="line">Users.get(&#123;id: <span class="string">'333'</span>&#125;); <span class="comment">// get /api/users/333</span></span><br></pre></td></tr></table></figure>
<p>可以看出<code>$resource</code> 使用起来比<code>$http</code>使用起来方便好多。<code>$resource</code>还支持 save(), delete等方法。</p>
<ul>
<li>get类方法的参数如下 get({params, successHandle, errorHandle})</li>
<li>非get类方法的参数 save({params, postData, successHandle, errorHandle})</li>
</ul>
<h4 id="$resource的附加属性">$resource的附加属性</h4><ul>
<li>$promise</li>
<li><p>$resolved</p>
<blockquote>
<p>这里不理解</p>
</blockquote>
</li>
</ul>
<h4 id="自定义$resource">自定义$resource</h4><p>前面的关于user的例子</p>
<ul>
<li>可以用get方法获取一个user.</li>
<li>可以根据id获取users</li>
</ul>
<p>那么就引申出两个问题</p>
<ul>
<li>怎么使用PATCH方法来修改user的一个字段</li>
<li>怎么根据username来获取一个user</li>
</ul>
<p>在这里就可以使用<code>$resource</code>的action 参数来自定义$resource<br>action的参数为<code>action1: {method:?, params:?, isArray:?, headers:?, ...}</code></p>
<ul>
<li><p>使用patch方法</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$resource(<span class="string">'/api/users/:id'</span>, &#123;id: <span class="string">'@id'</span>&#125;, &#123;</span><br><span class="line">	patch: &#123;method: <span class="string">'PATCH'</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据username获取user</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$resource(<span class="string">'/api/users/:id'</span>, &#123;id: <span class="string">'@id'</span>&#125;, &#123;</span><br><span class="line">	getByName: &#123;method: <span class="string">'GET'</span>, url: <span class="string">'/api/users/username-:username, params: &#123;username: '</span>@username<span class="string">'&#125;'</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>  这个容易犯一个错误就是为了根据用户名获取重新定义一个resource，但其实访问的都是users资源，是同一个，所以不应该建两个resource.</p>
</li>
</ul>
<h3 id="Restangular">Restangular</h3><p>是一个专门的Angular发RESTful的请求的库。<br><strong>需要新开一篇</strong></p>
<blockquote>
<ul>
<li>ETags </li>
<li>If-NoneMatch</li>
</ul>
</blockquote>
<h3 id="拦截器">拦截器</h3><p>如果我们要添加全局性的功能，如身份验证，错误处理的时候。就要用到拦截器。</p>
<p>拦截器的核心是服务工厂，通过向$httpProvider.intercetors数组中添加 factory service。</p>
<p>一共有四种拦截器，两种成功的，两种失败的</p>
<ul>
<li>request 请求成功</li>
<li>response 响应失败</li>
<li>requestError 请求失败 <strong>这个有什么用？</strong></li>
<li>responseError 响应失败</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'app'</span>).factory(<span class="string">'AuthHandler'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$q, $injector, loginUser</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> AuthHandler = &#123;&#125;;</span><br><span class="line">  AuthHandler.request = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (config.data &amp;&amp; config.data.$skipAuthHandler) &#123;</span><br><span class="line">      config.$skipAuthHandler = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">delete</span> config.data.$skipAuthHandler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config.params &amp;&amp; config.params.$skipAuthHandler) &#123;</span><br><span class="line">      config.$skipAuthHandler = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">delete</span> config.params.$skipAuthHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    config.headers.Authorization = loginUser.authorization();</span><br><span class="line">    <span class="keyword">return</span> $q.when(config);</span><br><span class="line">  &#125;;</span><br><span class="line">  AuthHandler.responseError = <span class="function"><span class="keyword">function</span> (<span class="params">rejection</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rejection.status === <span class="number">401</span> &amp;&amp; rejection.config &amp;&amp; !rejection.config.$skipAuthHandler) &#123;</span><br><span class="line">      $injector.get(<span class="string">'$state'</span>).go(<span class="string">'unauthorized'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $q.reject(rejection);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> AuthHandler;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">angular.module(<span class="string">'app'</span>).config(<span class="function"><span class="keyword">function</span> (<span class="params">RewriteHandlerProvider, $httpProvider</span>) </span>&#123;</span><br><span class="line">  $httpProvider.interceptors.push(<span class="string">'AuthHandler'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Angular_Conncet_with_Server">Angular Conncet with Server</h2><p>Angular与服务器通过<code>$http</code>通信。$http 服务简单的封装了浏览器原生的XMLHttpRequest]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Angular Service 学习笔记]]></title>
    <link href="http://wangximing.github.io/2016/03/02/AngularJS-Services/"/>
    <id>http://wangximing.github.io/2016/03/02/AngularJS-Services/</id>
    <published>2016-03-02T08:33:45.000Z</published>
    <updated>2016-03-05T13:52:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="创建服务的5中方式">创建服务的5中方式</h2><ul>
<li>factory()</li>
<li>service()</li>
<li>contant()</li>
<li>value()</li>
<li>provider()</li>
</ul>
<p><strong>service在Angular中是单例，只会被创建一次。</strong></p>
<h3 id="factory">factory</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> angular.module(<span class="string">'app'</span>)</span><br><span class="line"> 	.factory(<span class="string">'serviceName'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> 		<span class="comment">//在创建服务实例时被调用，只会被调用一次</span></span><br><span class="line"> 		<span class="keyword">var</span> productService = &#123;</span><br><span class="line"> 			filed: <span class="string">'hello'</span>;,</span><br><span class="line"> 			method: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">return</span> productService;</span><br><span class="line"> 	&#125;);</span><br><span class="line"></span><br><span class="line"> angular.controller(<span class="string">'Controller'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">serviceName</span>) </span>&#123;</span><br><span class="line">	serviceName.method();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="service()">service()</h3><p>service()函数会在创建实例时通过new关键字来实例化服务对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">angular.service(<span class="string">'serviceName'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.method =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">	<span class="keyword">this</span>.filed = <span class="string">'hello'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">angular.controller(<span class="string">'Controller'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">serviceName</span>) </span>&#123;</span><br><span class="line">	serviceName.method();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="provider()">provider()</h3><h4 id="factory()和provider()_**">factory()和provider() <em>**</em></h4><p>所有的factory()都是由$provider服务创建的, 假定传入的函数就是$get(), factory()就是provider()的简略形式。</p>
<blockquote>
<ul>
<li>$provider 和provider()的关系</li>
<li>$provider 和服务的关系</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'app'</span>)</span><br><span class="line">  .provider(<span class="string">'myService'</span>, &#123;</span><br><span class="line">  		$get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .factory(<span class="string">'myService'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="provider()定义的服务，可用于config()">provider()定义的服务，可用于config()</h4><p>myService是定义provider的名字，myServerProvider是服务的提供者。<br>如下使用（未验证）；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'app'</span>)</span><br><span class="line">  .provider(<span class="string">'myService'</span>, &#123;</span><br><span class="line">  		<span class="keyword">var</span> message = <span class="string">''</span>;</span><br><span class="line">  		setMessage: <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">  			message = message;</span><br><span class="line">  		&#125;</span><br><span class="line">  		$get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  			<span class="built_in">console</span>.log(message);</span><br><span class="line">  		&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .config(<span class="function"><span class="keyword">function</span>(<span class="params">myServiceProvider</span>) </span>&#123;</span><br><span class="line">  		myServiceProvider.setMessage(<span class="string">'say hello'</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="constant(),value()">constant(),value()</h3><p>constant()和value()都是注册一个变量为服务，可以注入到应用的其他部分。<br>不同的是<strong>constant()可以注入到config()中，而value()不可以</strong></p>
<h3 id="decorator()">decorator()</h3><p>decorator()可以对AngularJS的核心服务或者我们自己的服务进行里纳西，中断或者替换，Angular总的测试就是借助的$provider.decorator()建立的。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">decorator</span><span class="params">(<span class="string">'name'</span>, decoratorFn)</span></span></span><br><span class="line">name: 将要拦截的服务名称</span><br><span class="line">decoratorFn: 处理拦截的函数</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'app'</span>).config(<span class="function"><span class="keyword">function</span> (<span class="params">$provider</span>) </span>&#123;</span><br><span class="line">	$provider.decorator(<span class="string">'myService'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">//怎么做还没弄明白</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;) ;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>什么时候用factory()什么时候用service();<br>service()–&gt;factory()–&gt;provider()</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="创建服务的5中方式">创建服务的5中方式</h2><ul>
<li>factory()</li>
<li>service()</li>
<li>contant()</li>
<li>value()</li>
<li>provider()</li>
</ul>
<p]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Promise]]></title>
    <link href="http://wangximing.github.io/2016/01/11/Promise/"/>
    <id>http://wangximing.github.io/2016/01/11/Promise/</id>
    <published>2016-01-10T16:01:38.000Z</published>
    <updated>2016-01-15T07:34:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Promise_in_JavaScript">Promise in JavaScript</h2><h3 id="WHY">WHY</h3><p> Promise是一个古老的<strong>概念</strong>（1976），又叫Deferred(延期的)，Future<code>java.util.concurrent.Future</code>。<br> JavaScript是单线程，为了防止线程阻塞，在JS中有一种写法叫做<strong>回调</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.get(<span class="string">'/users/123'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//这里可以对User进行一些操作</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就解决了JS单线程的问题了，但是又引出了一个新的问题 回调地狱</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.get(<span class="string">'/users/123'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">class</span>) </span>&#123;</span><br><span class="line">     $.get(<span class="string">'/class/4'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">school</span>) </span>&#123;</span><br><span class="line">         $.get(<span class="string">'/schooles/123/chairman'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">class</span>) </span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">'get data'</span>);</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<p>回调地狱存在的明显的问题 难读而且也难测。然后为了解决这些问题，降低异步编程的复杂性，开发人员一直寻找简便的方法来处理异步操作，就出现了一个概念<strong>Promise</strong>和Promise的一系列的实现。Promise代表了一种可能会长时间运行而且不一定必须完整的操作的结果.</p>
<h3 id="WHAT">WHAT</h3><p>所谓Promise，字面上可以理解为”承诺”，就是说A调用B，B返回一个”承诺”给A，然后A就可以在写计划的时候这么写：当B返回结果给我的时候，A执行方案S1，反之如果B因为什么原因没有给到A想要的结果，那么A执行应急方案S2，这样一来，所有的潜在风险都在A的可控范围之内了。</p>
<p>Promise有三种状态</p>
<ul>
<li><code>pending</code>: 初始状态， new</li>
<li><code>fulfilled</code>: 表示操作成功//success callback</li>
<li><code>rejected</code>: 表示操作失败//failure callback</li>
</ul>
<h3 id="HOW">HOW</h3><ul>
<li><p><code>promise.then(success,failure)</code>,<code>promise.catch(failure)</code></p>
<p>  <code>promise.catch(failure)</code>相当于<code>promise.then(null, failure)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  vm.promise1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $http.get(<span class="string">'/users'</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'success1'</span>);</span><br><span class="line">      <span class="keyword">return</span> $http.get(<span class="string">'/users/success'</span>);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'error1'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'success2'</span>);</span><br><span class="line">      <span class="keyword">return</span> $http.get(<span class="string">'/users/error'</span>);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'error2'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'error3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .finally(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'finally'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//success1</span></span><br><span class="line"><span class="comment">//success2</span></span><br><span class="line"><span class="comment">//GET http://localhost:3000/users/error 500 (Internal Server Error)</span></span><br><span class="line"><span class="comment">//error3</span></span><br><span class="line"><span class="comment">//finally</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 Promise 被 reject，后面的 then 又没有指定失败回调，会找后面的失败回调。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$http.get(<span class="string">'/users/error'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success1'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success2'</span>);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error1'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error2'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finally'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//GET http://localhost:3000/users/error</span></span><br><span class="line">    <span class="comment">//view1.js:44 error2</span></span><br><span class="line">    <span class="comment">//view1.js:50 finally</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果Promise失败，那么失败回调后会调用下一个then的成功回调</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$http.get(<span class="string">'/users/error'</span>)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error1'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success1'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finally'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"> <span class="comment">//GET http://localhost:3000/users/error 500 (Internal Server Error)</span></span><br><span class="line"> <span class="comment">//error1</span></span><br><span class="line"> <span class="comment">// success1</span></span><br><span class="line"> <span class="comment">// finally</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果Promise失败且返回了一个Promise，在后面的then的参数里会被拆开。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$http.get(<span class="string">'/users/error'</span>)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $http.get(<span class="string">'/users/success'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success1'</span>);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finally'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//GET http://localhost:3000/users/error 500 (Internal Server Error)</span></span><br><span class="line"><span class="comment">//success1</span></span><br><span class="line"><span class="comment">//finally</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>angular的all, defer, reject方法</p>
</li>
<li>不仅仅是Ajax</li>
</ul>
<h2 id="MORE">MORE</h2><ul>
<li><a href="http://alinode.aliyun.com/blog/5" target="_blank" rel="external">Promise的前世今生</a></li>
<li><a href="http://api.jquery.com/category/deferred-object/" target="_blank" rel="external">jQuery Deferred</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">MDN Promise</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html" target="_blank" rel="external">jQuery的deferred对象详解 | 阮一峰</a></li>
<li><a href="https://promisesaplus.com/#point-11" target="_blank" rel="external">Promises/A+</a></li>
<li><a href="http://callbackhell.com/" target="_blank" rel="external">回调地狱</a></li>
</ul>
<h2 id="OTHERS">OTHERS</h2><p><a href="https://github.com/kuitos/kuitos.github.io/issues/32#issuecomment-170256304" target="_blank" rel="external">2015前端生态发展回顾</a></p>
<ul>
<li>年初React Native的发布，引领React正式走上历史舞台。</li>
<li>3月angular2.0第一个预览版发布</li>
<li>5月 http/2.0标准正式发布，同月 iojs 与 nodejs合并。</li>
<li>6月 ES6 和 WebAssembly 落地</li>
<li>7月 迄今为止React生态圈影响最大的Flux实现redux发布1.0版本</li>
<li>8月 Facebook公开了在React上应用GraphQL的relay框架的技术预览版</li>
<li>9月 React Native for Andriod 发布</li>
<li>11月伊始，es标准委员会宣布将历时3年研究的Object.observe从草案中移除，尽管它原本已经是stage2，几乎已经是ES7的事实标准。双十一刚一结束，阿里手淘团队发布了名为 无线电商动态化解决方案 的 Weex，也有人给了它一个更具象的名字，vue native。</li>
<li>12月，赶在2015的尾巴，aurelia和angular2先后发布beta版。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Promise_in_JavaScript">Promise in JavaScript</h2><h3 id="WHY">WHY</h3><p> Promise是一个古老的<strong>概念</strong>（1976），又叫Deferred(延期的)，Fut]]>
    </summary>
    
      <category term="JavaScript Promise" scheme="http://wangximing.github.io/tags/JavaScript-Promise/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[css]]></title>
    <link href="http://wangximing.github.io/2015/12/01/css/"/>
    <id>http://wangximing.github.io/2015/12/01/css/</id>
    <published>2015-12-01T14:54:24.000Z</published>
    <updated>2015-12-01T15:05:29.000Z</updated>
    <content type="html"><![CDATA[<h3 id="设置文字的text-overflow:ellipsis">设置文字的text-overflow:ellipsis</h3><p>有几个前提：</p>
<ul>
<li>容器定宽 （width=100px）</li>
<li>去除空白 （white-space:nowrap）</li>
<li>溢出隐藏：overflow:hidden</li>
<li>文字省略： text-overflow:ellipsis</li>
</ul>
<h3 id="AngularUI_Bootstrap_popover的使用">AngularUI Bootstrap popover的使用</h3><p>现在在一个滚动栏内使用popover，因为滚动栏设置的是 overflow=auto,导致popover多出的部分会藏在滚动栏里面。如图</p>
<p>解决的办法是利用popover的popover-append-to-body属性设置为true<code>popover-append-to-body=true</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="设置文字的text-overflow:ellipsis">设置文字的text-overflow:ellipsis</h3><p>有几个前提：</p>
<ul>
<li>容器定宽 （width=100px）</li>
<li>去除空白 （white-space:no]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[我与思沃学院]]></title>
    <link href="http://wangximing.github.io/2015/12/01/%E6%88%91%E4%B8%8E%E6%80%9D%E6%B2%83%E5%AD%A6%E9%99%A2/"/>
    <id>http://wangximing.github.io/2015/12/01/我与思沃学院/</id>
    <published>2015-12-01T14:54:16.000Z</published>
    <updated>2015-12-05T15:43:51.000Z</updated>
    <content type="html"><![CDATA[<p>距离最开始接触学院到现在，已经也快有一年半的时间了。这一年来的身份也经历了从学员-实习生-学员到最后成为公司的一名员工的不同的转变。期间包含了在思沃学院被培训，在思沃学院实习，不在思沃学院的三种不同的角色。想谈一谈我对思沃学院的认识。</p>
<p>思沃学院或者是以前的仝键技校或者是之后的什么什么，不管名字怎么变，做的事情都是培训。在TW培训体系中，思沃学院是属于从入职前+试用期的工作的这段时间的。其中入职前的培训主要有在校生培养到拿offer和拿到offer的人到入职前的这段时间。试用期主要指的是总理在做的对毕业生的访谈跟踪的工作。或许以后会再往下（扩展公司培训体系的「下」）发展到做一些事情直接影响学校的教学，或许往上发展会承担更多的新人在试用期的培养工作。这是我对思沃学院在公司的一个位置的理解。</p>
<p>最近有被问道好多个关于思沃学院的问题，比如说你认为思沃学院是做什么的，你在思沃学院到学到了什么，你感觉思沃学院对你的培训重要么，思沃学院和TWU的区别在哪里的各种问题。我自己平时也有思考这些问题，特别是不在思沃学院之后，我认真的回顾了在思沃学院经历的各种事情，以一个相对「局外人」的角度，思考了在思沃学院学习的这段经历。</p>
<p>关于思沃学院是做什么的。从一个在校学生的角度来讲，思沃学院是一个可以学到知识的地方，一个可以学习到公司是怎么做事的地方，一个可能的去TW工作的机会。从公司的角度来讲，思沃学院是一个可以让更多的学生，学校知道了解公司的机构，一个可以给公司输送员工的地方，一个可以对提高应届生上项目时能力的地方，更重要的是公司扩大规模后的新人培养方式的一种尝试。</p>
<p>思沃学院的培训对我来说很重要，不仅仅是学到了多少知识，更重要的是在刚开始的时候就走在一个正确的道路上（敏捷实践，自我学习等）。我经历过思沃学院在校生到拿到offer的这段时间的培训，思沃学院教得内容有简单的编程训练 clean code 重构 tdd和一些其他的敏捷实践，还有一些命令行，git等得使用。思沃学院的培训还是很重要的，我们当时的9个人，之前没有编程经验的培训后和好像写了一年代码的样子，有过编程经验的我再看自己之前写的代码也是觉得烂不行。就我自身来说，编程的素养提高了，编码的能力也提高了不少。说不出什么具体的可以度量的东西，但就是有种高了一个level的感觉。</p>
<p>思沃学院和TWU的区别，或者说是不同、差距在哪里。我想这对思沃学院是非常重要。</p>
<p>还记得当时有听过仝老师讲到过一个『标准化』和『精品课程』的问题，去了TWU后真切的感受到了『标准化』，当时仝老师对标准化的解释是有一个教学大纲、有上课的PPT、有这节课讲的重点和检查标准等。有一套标准在这里，随便来一个人，经过短时间的培训，拿着这个标准化的课程资料，就可以去教这节课了。思沃学院现在正在实现标准化的道路上前行，相信在仝老师的带领下，很快就可以达成这个目标。再加上思沃学院有固定的和很认真负责且愿意投入大量时间到教育培训上的老师，思沃学院一定会越走越好。也建议老师们去感受下TWU的教学。</p>
<p>当然思沃学院还有许多要改进的地方。在思沃学院还没有实现标准化和精品课程的现在，思沃学院的教学还是主要靠”人”，一节课怎么讲主要看个人怎么讲的，这样子其实很局限于某个人得知识范围，在一些有争议的问题上容易导致一家之言，其实并不是很好，一个人也不把所有的敏捷实践，编码的最佳实践做都到很好。所以有一个建议就是尽量不同的人讲不同课，并且有一个pair在一边当”观察者”。</p>
<p>因为思沃学院是一个相对较新的团队，加上一直在外办公。所以就导致公司好多同事对思沃学院不是很熟悉。希望我的这篇文章可以解答大家的一些疑惑。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>距离最开始接触学院到现在，已经也快有一年半的时间了。这一年来的身份也经历了从学员-实习生-学员到最后成为公司的一名员工的不同的转变。期间包含了在思沃学院被培训，在思沃学院实习，不在思沃学院的三种不同的角色。想谈一谈我对思沃学院的认识。</p>
<p>思沃学院或者是以前的仝键]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[scss]]></title>
    <link href="http://wangximing.github.io/2015/11/17/scss/"/>
    <id>http://wangximing.github.io/2015/11/17/scss/</id>
    <published>2015-11-17T13:00:59.000Z</published>
    <updated>2015-11-17T13:03:54.000Z</updated>
    <content type="html"><![CDATA[<p>css不是一种编程语言，sass为css加入了编程元素。<br>sass的后缀是.scss。sassy css。</p>
<h3 id="编译风格">编译风格</h3><ul>
<li>nested 嵌套缩进的css代码，反映了HTML DOM 的结构。</li>
<li>expended: 没有嵌套缩进的css</li>
<li>compact ：</li>
<li>compressed：</li>
</ul>
<h3 id="变量">变量</h3><p>以$开头在sass中被认为是变量<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$font-color</span><span class="value">: <span class="hexcolor">#333</span>;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="导入">导入</h3><p>reset.scss<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ol &#123;&#10;&#9;margin:0&#10;&#9;padding:0&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &#39;reset&#39;;&#10;bodyy &#123;&#10;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html, body, ul, ol &#123;&#10;  margin: 0;&#10;  padding: 0;&#10;&#125;&#10;&#10;body &#123;&#10;  font: 100% Helvetica, sans-serif;&#10;  background-color: #efefef;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mixin">Mixin</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@mixin border-radius($radius) &#123;&#10;  -webkit-border-radius: $radius;&#10;     -moz-border-radius: $radius;&#10;      -ms-border-radius: $radius;&#10;          border-radius: $radius;&#10;&#125;&#10;&#10;.box &#123; @include border-radius(10px); &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.box</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-border-radius</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">-moz-border-radius</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">-ms-border-radius</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="继承">继承</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.message</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="hexcolor">#ccc</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="hexcolor">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.success</span> &#123;</span><br><span class="line">  <span class="variable">@extend</span> .message;</span><br><span class="line">  <span class="attribute">border-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.error</span> &#123;</span><br><span class="line">  <span class="variable">@extend</span> .message;</span><br><span class="line">  <span class="attribute">border-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.warning</span> &#123;</span><br><span class="line">  <span class="variable">@extend</span> .message;</span><br><span class="line">  <span class="attribute">border-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.message</span>, <span class="class">.success</span>, <span class="class">.error</span>, <span class="class">.warning</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#cccccc</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#333</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.success</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">border-color</span>:<span class="value"> green</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.error</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">border-color</span>:<span class="value"> red</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.warning</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">border-color</span>:<span class="value"> yellow</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="运算_operators">运算 operators</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">article</span><span class="attr_selector">[role="main"]</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">600px</span> / <span class="number">960px</span> * <span class="number">100%</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">aside</span><span class="attr_selector">[role="complimentary"]</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">float</span>:<span class="value"> right</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">300px</span> / <span class="number">960px</span> * <span class="number">100%</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>css不是一种编程语言，sass为css加入了编程元素。<br>sass的后缀是.scss。sassy css。</p>
<h3 id="编译风格">编译风格</h3><ul>
<li>nested 嵌套缩进的css代码，反映了HTML DOM 的结构。</li>
<li>]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[ionic header bar]]></title>
    <link href="http://wangximing.github.io/2015/10/27/ionic-header-bar/"/>
    <id>http://wangximing.github.io/2015/10/27/ionic-header-bar/</id>
    <published>2015-10-27T03:32:42.000Z</published>
    <updated>2015-11-17T13:05:46.000Z</updated>
    <content type="html"><![CDATA[<p>参考：<a href="http://learn.ionicframework.com/formulas/navigation-bar-vs-header-bar/" target="_blank" rel="external">ionic 官方教程</a>;</p>
<p>我们可以用<code>ion-header-bar</code>,<code>ion-nav-bar</code>的任意一个来进行显示导航栏。<br>两者的区别在于，</p>
<p><code>ion-header-bar</code>可以做进一步的样式设置扩展，比如说在两侧加上按钮等。</p>
<p><img src="/image/nav-extention.png" alt="导航栏扩展"></p>
<p><code>ion-nav-bar</code> 集成了<code>Ionic router</code>和历史路径的压栈。使用后可以回退到上一个浏览的页面。</p>
<p><img src="/image/nav-back.png" alt="导航栏回退"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>参考：<a href="http://learn.ionicframework.com/formulas/navigation-bar-vs-header-bar/" target="_blank" rel="external">ionic 官方教程</a>;</p>
<p]]>
    </summary>
    
  </entry>
  
</feed>
