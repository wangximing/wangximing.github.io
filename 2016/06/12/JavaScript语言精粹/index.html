<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="sigh | 王西明 | wangximing"><title>JavaScript语言精粹（1） | sigh</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JavaScript语言精粹（1）</h1><a id="logo" href="/.">sigh</a><p class="description">音乐是情感的独白</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首頁</i></a><a href="/archives/"><i class="fa fa-archive"> 所有文章</i></a><a href="/about/"><i class="fa fa-user"> 關於</i></a><a href="/atom.xml"><i class="fa fa-rss"> 訂閱</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JavaScript语言精粹（1）</h1><div class="post-meta">Jun 12, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h2 id="语法">语法</h2><h3 id="标识符">标识符</h3><ul>
<li>由字母开头</li>
<li>不能使用保留字</li>
<li>JavaScript不允许在<strong>对象字面量</strong>中，或者用点运算符提取对象属相时，使用保留字作为属性名。</li>
</ul>
<h3 id="数字">数字</h3><p>只有一个数字类型，在内部被表示为64为浮点数，没有分离出整数类型。</p>
<ul>
<li>1=== 1.0</li>
<li>NaN是一个数值，它表示一个不能产生正常结果的运算结果。NaN不等于任何值，包括它自己。</li>
<li>Infinity 无穷大</li>
</ul>
<h3 id="字符串">字符串</h3><ul>
<li>JavaScript中所有字符都是16位的。</li>
<li>字符串是不可变的，一旦字符串被创建，就无法改变它。</li>
<li>两个包含着完全相同的字符切字符顺序也相同的字符串被认为是相同的字符串。  <code>&#39;a&#39; + &#39;b&#39; = &#39;ab&#39;</code></li>
</ul>
<h3 id="语句（Statements）">语句（Statements）</h3><ul>
<li>包在花括号中的语句不会创建作用域。</li>
<li>当 var语句被用字函数内部时，它定义的是这个函数的私有变量。</li>
<li><p>falsy </p>
<blockquote>
<p>false,null,undefined, ‘’, 0, NaN</p>
</blockquote>
</li>
<li><p>truly</p>
<blockquote>
<p>true, ‘false’等所有。</p>
</blockquote>
</li>
<li><p>简单的for循环</p>
</li>
<li>for..in循环<br>  for..in会枚举一个对象的所有属性名，并且通常要通过object.hasOwnProperty(variable)来约定这个属性名是该对象的成员还是来自原型链。</li>
</ul>
<h3 id="表达式（Expressions）">表达式（Expressions）</h3><ul>
<li><p>typeof的值有 ‘number’, ‘string’, ‘boolean’, ‘undefined’, ‘function’, ‘object’。</p>
<blockquote>
<ul>
<li>typeof null //object</li>
<li>type [] //object</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="字面量">字面量</h3><p>对象字面量是一种可以方面的按指定规格创建对象的表示法</p>
<ul>
<li>{}， []</li>
</ul>
<h3 id="函数_Functions">函数 Functions</h3><h2 id="对象">对象</h2><p>简单数据类型： 数字，字符串，布尔值，null，undefined</p>
<p>对象： 函数，数组，对象。</p>
<h3 id="对象字面量">对象字面量</h3><ul>
<li>{}</li>
</ul>
<h3 id="检索">检索</h3><ul>
<li>a.b</li>
<li>a[b]</li>
<li>|| 运算符可以用来填充默认值 <code>var name = a.b || &#39;Bob&#39;</code></li>
<li><p>&amp;&amp; 可以用来避免错误 </p>
<blockquote>
<ul>
<li>flight.a   //undefined</li>
<li>flight.a.b  //error</li>
<li>flight.a &amp;&amp; flight.a.b  //undefined </li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="引用">引用</h3><p>对象通过引用来传递，它们永远不会被复制</p>
<h3 id="原型">原型</h3><ul>
<li>set不会更新原型</li>
<li>get会检索原型</li>
</ul>
<h3 id="反射">反射</h3><p>原型链中的任何属性都会产生值</p>
<ul>
<li>typeof flight.toString  //function</li>
<li>typeof flight.constructor  //function</li>
</ul>
<h3 id="枚举">枚举</h3><p>for..in 语句可与来遍历一个对象的所有属性，不过要排除原型链中的属性</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(name in <span class="class"><span class="keyword">object</span>)&#123;</span></span><br><span class="line">	<span class="keyword">if</span>(typeof <span class="class"><span class="keyword">object</span>[</span>name] !== function &amp;&amp; <span class="class"><span class="keyword">object</span>.<span class="title">hasOWnProperty</span>(</span>name))&#123;</span><br><span class="line">		console.log(<span class="class"><span class="keyword">object</span>[</span>name])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>for..in属性名出现的是不固定的</li>
</ul>
<h3 id="删除">删除</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;b: <span class="string">'b'</span>, c: <span class="string">'c'</span>&#125;;</span><br><span class="line"></span><br><span class="line">delete a.b;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 减少全局变量的污染</span></span><br><span class="line"></span><br><span class="line">使用命名空间减少全局遍历的污染</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">## 函数</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 函数对象</span></span><br><span class="line"></span><br><span class="line">每个函数再创建的时候回附加两个属性，函数的上下文和实现函数行为的代码。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 函数字面量</span></span><br><span class="line"></span><br><span class="line">函数字面量创建的函数对象包含一个连接到外部的上下文，被称为闭包。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 调用</span></span><br><span class="line"></span><br><span class="line">* 函数调用时会传两个附加参数 <span class="keyword">this</span>,arguemnts。</span><br><span class="line">* 当实际参数个数比形参多时，超出的参数会被忽略。</span><br><span class="line">* 实际参数比形参少时，缺失的值会被置为undefined。</span><br><span class="line">* 四种调用模式：方法调用模式，函数调用模式，构造器调用模式，apply调用模式。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 方法调用模式</span></span><br><span class="line"></span><br><span class="line">当一个函数被保存为一个对象的属性时，成为方法。而这时的调用成为方法调用。</span><br></pre></td></tr></table></figure>
<p>var object = {<br>    value: 0;<br>    doSomething : function() {<br>        this.value = 9;<br>    }<br>}<br>object.doSometing();<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这时方法内的<span class="keyword">this</span>指的是方法所在的<span class="keyword">object</span>。所以它可以访问和修改对象的属性。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 函数调用模式</span></span><br><span class="line"></span><br><span class="line">当一个函数并非一个对象的属性时，它就是被当做函数来调用的。这时函数内的<span class="keyword">this</span>绑定的是全局对象。</span><br><span class="line"></span><br><span class="line">解决办法是把这个函数包一层并绑定到一个对象上</span><br></pre></td></tr></table></figure></p>
<p>var a = add(4, 5)<br>object.double  = function(){<br>    var that = this;<br>    var helper = function(){<br>        return add(that.a, that.b);<br>    };</p>
<pre><code>helper()<span class="comment">;</span>
</code></pre><p>}<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">### 构造器调用模式</span></span><br><span class="line"></span><br><span class="line">使用<span class="keyword">new</span>的方式调用。</span><br></pre></td></tr></table></figure></p>
<p>var Person = function(firstName) {<br>  this.firstName = firstName;<br>};</p>
<p>Person.prototype.walk = function(){<br>  console.log(“I am walking!”);<br>};</p>
<p>function Student(firstName, subject) {<br>  Person.call(this, firstName);<br>  this.subject = subject;<br>}</p>
<p>Student.prototype = Object.create(Person.prototype);</p>
<p>Student.prototype.constructor = Student;<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### apply调用模式</span></span><br><span class="line"></span><br><span class="line">函数可以拥有方法，<span class="keyword">apply</span>方法让我们传递一个参数数组给函数</span><br></pre></td></tr></table></figure></p>
<p>var array = [3, 4];<br>app.apply(null, array);<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apply 方法接受两个参数，第一个用于绑定<span class="keyword">this</span>,第二个用于传递参数。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 返回</span></span><br><span class="line"></span><br><span class="line">* 函数总会有返回值，如果没有指定则返回undefined；</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 异常</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 扩充类型的功能</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 递归</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 作用域</span></span><br><span class="line"></span><br><span class="line">* JavaScript有函数作用域，定义在函数内部的参数和变量在外部是不可见的。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 闭包（P38）</span></span><br><span class="line"></span><br><span class="line">* 作用域的好处是内部的函数可以访问定义它们的外部函数的参数和变量（除<span class="keyword">this</span>，arguments）。</span><br><span class="line">* 内部函数比外部函数有更长的生命周期。</span><br></pre></td></tr></table></figure></p>
<p>var quo = function(status) {<br>    return {<br>        get_status: function(){<br>            return status;<br>        }<br>    }<br>}</p>
<p>var myQuo = quo(‘hello’);<br>console.log(myQuo.get_status());<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">* </span>即使quo已经返回了，但get_status方法仍然享有访问quo对象status属性的权利</span><br><span class="line"><span class="bullet">* </span>get_status返回的并不是status参数的一个副本，返回的就是status属性本身。</span><br><span class="line"><span class="bullet">* </span>函数可以访问它被创建是所处的上下文，这被成为闭包。</span><br><span class="line"></span><br><span class="line"><span class="header">### 回调</span></span><br><span class="line"></span><br><span class="line"><span class="header">### 模块</span></span><br><span class="line">通过使用函数和闭包来构造模块</span><br></pre></td></tr></table></figure></p>
<p>var a = function() {<br>    var x = 9;</p>
<pre><code><span class="tag">return</span> <span class="rules">{
    <span class="rule"><span class="attribute">setX</span>:<span class="value"> <span class="function">function</span>(input) {
        x = input</span></span>;
    }</span>,
    <span class="rule"><span class="attribute">getX</span>:<span class="value"> <span class="function">function</span>() {
        return x</span></span>;
    }
}
</code></pre><p>}<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">### 级联</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 柯里化</span></span><br><span class="line"></span><br><span class="line">把函数和传递给它的参数结合，生成一个新的函数。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 记忆？？？</span></span><br><span class="line"></span><br><span class="line">函数可以将先前的操作结果记录在某个对象中，从而避免无所谓的重复计算。这种优化被称为「记忆」</span><br><span class="line"></span><br><span class="line">p44</span><br><span class="line"></span><br><span class="line">斐波那契的例子</span><br></pre></td></tr></table></figure></p>
<p>var fibonacci = function() {<br>    return n &lt; 2 ? n : fibonacci(n-1) + fibonicci(n-2);<br>}</p>
<p>for(var i = 0; i &lt;= 10; i++) {<br>    console.log(fibonacci(i));<br>}</p>
<p>fibonacci共被调用了453次，我们调用11次，本身调用442次</p>
<p>var fibonacci  = function() {<br>    var memo = [0, 1];</p>
<pre><code><span class="keyword">var</span> fib = function(n) {
    <span class="keyword">var</span> <span class="literal">result</span> = memo[n];

    <span class="keyword">if</span>(typeof <span class="literal">result</span> !== 'number') {
        <span class="literal">result</span> = fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);
        memo[n] = reuslt;
    }
    <span class="literal">result</span> <span class="literal">result</span>;
};

retuern fib;
</code></pre><p>}</p>
<p>计算29次，我们调用11次，自己调用18次。<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">## 继承</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 简介</span></span><br><span class="line"></span><br><span class="line">JavaScript是一门基于原型的语言，着意味着对象直接从其他对象继承。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 模拟基于类的继承</span></span><br></pre></td></tr></table></figure></p>
<p>var Person = function(firstName) {<br>  this.firstName = firstName;<br>};</p>
<p>Person.prototype.walk = function(){<br>  console.log(“I am walking!”);<br>};</p>
<p>function Student(firstName, subject) {<br>  Person.call(this, firstName);<br>  this.subject = subject;<br>}</p>
<p>Student.prototype = Object.create(Person.prototype);</p>
<p>Student.prototype.constructor = Student;<br>```</p>
<h3 id="函数化">函数化</h3><p>使用应用块模式来完成私有变量模式。</p>
<h3 id="部件">部件</h3><h2 id="数组">数组</h2><h3 id="数组字面量">数组字面量</h3><p>var array = [];<br>var numbers = [1, 2, 3];</p>
<ul>
<li>JS允许数组包含任意混合类型的值</li>
</ul>
<h3 id="长度">长度</h3><ul>
<li>length属性的值是这个数组的最大整数属性名加上1， 他不一定等于数组里属性的个数</li>
<li>设置更大的length不会给数组分配更多的空间，而把length设小将导致下标大于等于length的属性被删除</li>
<li>给数组追加一个值 numbers[numbers.length] = ‘hello’, numbers.push(‘hello’);</li>
</ul>
<h3 id="删除-1">删除</h3><ul>
<li><p>使用delete删除数组元素后会留下一个空洞 delete numbers[2],</p>
</li>
<li><p>使用splice删除元素，numbers.splice(start, length);</p>
</li>
</ul>
<h3 id="遍历">遍历</h3><h3 id="区别数组和对象">区别数组和对象</h3><ul>
<li><p>input &amp;&amp; typeof input === ‘object’ &amp;&amp; input.constructor === Array;</p>
<p>  但识别从不同窗口，帧构建的数组时会失败</p>
</li>
<li><p>Object.prototype.toString.apply(value) === ‘[object Array]’;//true 数组</p>
<p>  这种方式适合各种情况</p>
</li>
</ul>
<h3 id="扩展数组方法">扩展数组方法</h3><h3 id="指定初始值">指定初始值</h3></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://wangximing.github.io/2016/06/12/JavaScript语言精粹/" data-id="ciu6cxfr0001hrffy90ea3doj" class="article-share-link">分享至</a><div class="tags"><a href="/tags/前端/">前端</a></div><div class="post-nav"><a href="/2016/06/22/JavaScript语言精粹2/" class="pre">JavaScript语言精粹（2）</a><a href="/2016/05/12/前端小知识/" class="next">前端小知识</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://wangximing.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分類</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 標籤</i></div><div class="tagcloud"><a href="/tags/Ruby-错误处理与异常/" style="font-size: 15px;">Ruby 错误处理与异常</a> <a href="/tags/游览/" style="font-size: 15px;">游览</a> <a href="/tags/CSS-Background/" style="font-size: 15px;">CSS Background</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/test/" style="font-size: 15px;">test</a> <a href="/tags/Spring-Boot/" style="font-size: 15px;">Spring Boot</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/Ruby-运算符/" style="font-size: 15px;">Ruby 运算符</a> <a href="/tags/JavaScript-Promise/" style="font-size: 15px;">JavaScript Promise</a> <a href="/tags/JavaScript-jQuery/" style="font-size: 15px;">JavaScript jQuery</a> <a href="/tags/ASCII-Unicode-JavaScript-encode/" style="font-size: 15px;">ASCII, Unicode, JavaScript encode</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/09/19/vue/">vue</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/02/ES67/">ES67</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/redux/">redux</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/AngularJS深度剖析与最佳实践/">AngularJS深度剖析与最佳实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/28/ES6学习笔记/">ES6学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/22/JavaScript语言精粹2/">JavaScript语言精粹（2）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/12/JavaScript语言精粹/">JavaScript语言精粹（1）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/12/前端小知识/">前端小知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/29/CSS_Background/">CSS Background</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/23/css代码规范/">CSS 规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友站連結</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">sigh.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>